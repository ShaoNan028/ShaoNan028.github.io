<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UI组件库选型</title>
    <link href="/2024/11/14/UI%E7%BB%84%E4%BB%B6%E5%BA%93%E9%80%89%E5%9E%8B/"/>
    <url>/2024/11/14/UI%E7%BB%84%E4%BB%B6%E5%BA%93%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>选择 UI 组件库时的相关考虑事项</p><span id="more"></span><h2 id="选择原则"><a href="#选择原则" class="headerlink" title="选择原则"></a>选择原则</h2><h3 id="1-技术栈兼容性"><a href="#1-技术栈兼容性" class="headerlink" title="1. 技术栈兼容性"></a>1. 技术栈兼容性</h3><ul><li><strong>框架适配</strong>：确保 UI 组件库与你的项目所使用的前端框架兼容。例如，如果你的项目是基于 Vue.js 开发的，就应该选择 Vue.js 专用的 UI 组件库，像 Element Plus、Ant Design Vue 等；若是基于 React，那么 Ant Design React、Material - UI 等是比较合适的选择。使用与框架不兼容的组件库可能会导致复杂的集成问题，甚至无法正常工作。</li><li><strong>JavaScript 版本支持</strong>：检查组件库是否支持你的项目所使用的 JavaScript 版本。一些较新的组件库可能依赖于 ES6 +的特性，若你的项目由于某些原因（如需要兼容旧浏览器）还在使用 ES5，那么需要确保所选组件库能够在这种环境下正常运行，或者你有能力对其进行适当的转译。</li></ul><h3 id="2-设计风格与主题定制"><a href="#2-设计风格与主题定制" class="headerlink" title="2. 设计风格与主题定制"></a>2. 设计风格与主题定制</h3><ul><li><strong>设计风格匹配</strong>：UI 组件库的设计风格要与项目的整体设计理念相契合。例如，如果你正在开发一个面向企业级用户的管理系统，那么可能更适合选择具有简洁、专业风格的组件库，如 Ant Design 系列；而如果是一个创意型的项目，像一些具有独特视觉风格的 Material - UI 之类的组件库可能更符合需求。</li><li><strong>主题定制能力</strong>：考虑组件库是否提供足够的主题定制选项。这包括颜色、字体、大小等基本样式的定制，以及更复杂的组件样式定制，如按钮形状、菜单样式等。强大的主题定制功能可以让你根据项目的品牌形象或特定的设计要求轻松地调整组件外观。</li></ul><h3 id="3-组件丰富度与质量"><a href="#3-组件丰富度与质量" class="headerlink" title="3. 组件丰富度与质量"></a>3. 组件丰富度与质量</h3><ul><li><strong>组件种类和功能完整性</strong>：一个好的 UI 组件库应该提供丰富多样的组件来满足项目的各种需求。除了常见的按钮、表单、表格等基本组件外，还应包含更复杂的组件，如日期选择器、树形组件、图表组件等。同时，这些组件的功能应该完整，能够覆盖大多数常见的业务场景。例如，表格组件应支持排序、筛选、分页等功能。</li><li><strong>组件质量与稳定性</strong>：查看组件库的文档质量、示例代码完整性以及社区反馈来评估组件的质量。高质量的组件库通常具有详细、准确的文档，包括组件的使用方法、属性说明、事件处理等内容。丰富的示例代码可以帮助你快速上手并理解组件的实际应用场景。此外，参考社区的评价和问题反馈，了解组件是否存在已知的漏洞、性能问题或兼容性问题。</li></ul><h3 id="4-性能表现"><a href="#4-性能表现" class="headerlink" title="4. 性能表现"></a>4. 性能表现</h3><ul><li><strong>代码体积和加载速度</strong>：关注组件库的代码体积，特别是在移动端或对性能要求较高的项目中。较大的代码体积可能会导致页面加载速度变慢，影响用户体验。有些组件库提供了按需加载的功能，可以根据实际使用的组件来减小打包后的代码体积，这是一个很有用的特性。</li><li><strong>运行时性能</strong>：了解组件库在运行时的性能表现，如组件的渲染速度、交互响应速度等。一些组件库可能由于复杂的内部逻辑或过度的动画效果而导致性能下降，尤其是在处理大量数据或复杂布局的情况下。可以通过性能测试工具或者参考其他用户的性能评测来评估组件库的运行时性能。</li></ul><h3 id="5-社区支持与维护"><a href="#5-社区支持与维护" class="headerlink" title="5. 社区支持与维护"></a>5. 社区支持与维护</h3><ul><li><strong>社区活跃度</strong>：选择具有活跃社区的 UI 组件库是非常重要的。活跃的社区意味着有更多的人在使用和贡献这个组件库，遇到问题时可以更容易地在社区中找到解决方案，同时也增加了组件库更新和改进的可能性。可以通过查看组件库的 GitHub 仓库的星标数、提交频率、问题反馈和回答情况等来评估社区活跃度。</li><li><strong>维护更新情况</strong>：确保组件库仍在持续维护中，并且能够及时跟上前端技术的发展和浏览器的更新。一个长期不更新的组件库可能会出现兼容性问题，或者无法利用新的技术优势来提升性能和功能。查看组件库的更新日志，了解其更新频率和内容，例如是否修复了安全漏洞、优化了性能或者添加了新的组件。</li></ul><h3 id="6-国际化与无障碍支持"><a href="#6-国际化与无障碍支持" class="headerlink" title="6. 国际化与无障碍支持"></a>6. 国际化与无障碍支持</h3><ul><li><strong>国际化支持</strong>：如果你的项目面向全球用户，需要考虑组件库是否提供良好的国际化（i18n）支持。这包括文本内容的国际化（如按钮标签、提示信息等可以方便地切换语言）以及日期、数字等格式的国际化处理。</li><li><strong>无障碍访问支持</strong>：确保组件库遵循无障碍访问（a11y）标准，使得残障人士（如视障、听障等用户）也能够方便地使用你的应用。例如，组件应该具有合适的语义化标签、键盘可访问性等特性。</li></ul><h2 id="选型实践"><a href="#选型实践" class="headerlink" title="选型实践"></a>选型实践</h2><h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h3><p>vue3 框架+uniapp 实现的前端项目，运行在 app、h5、小程序等多个平台。<br>业务范围：商品售卖，订单发货，评论留言等。</p><h3 id="2-可选组件库"><a href="#2-可选组件库" class="headerlink" title="2. 可选组件库"></a>2. 可选组件库</h3><p>vant<br><a href="https://vant-ui.github.io/vant/#/zh-CN/home">vant 中文官网</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂下载文件</title>
    <link href="/2024/07/11/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
    <url>/2024/07/11/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>除了导入文件，后台管理还经常涉及到导出文件的需求。如何从服务器请求文件并下载，涉及到哪些知识，争取用一篇文章搞懂。</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">downloadByPost</span>(<span class="hljs-attr">url</span>: string|any,<span class="hljs-attr">postData</span>:any,fileName?:string):<span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ArrayBuffer</span> | <span class="hljs-literal">undefined</span>&gt; &#123;<br>     fileName = fileName||<span class="hljs-string">&#x27;error-file.xlsx&#x27;</span>;<br><br>      <span class="hljs-keyword">return</span>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">post</span>(url,postData,&#123;<span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;arraybuffer&#x27;</span>&#125;).<span class="hljs-title function_">pipe</span>(<br>      <span class="hljs-title function_">tap</span>(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span>  newBlob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([result ] );<br>        <span class="hljs-keyword">const</span> newUrl = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(newBlob);<br>        <span class="hljs-keyword">const</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>        link.<span class="hljs-property">href</span> = newUrl;<br><br>        link.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;download&#x27;</span>, fileName);<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(link);<br>        link.<span class="hljs-title function_">click</span>();<br>        link.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(link);<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(newUrl);<br>      &#125;),<br>      <span class="hljs-title function_">debounceTime</span>(<span class="hljs-number">500</span>)).<span class="hljs-title function_">toPromise</span>();<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">download</span>(<span class="hljs-params">url: string, name: string</span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-title function_">get</span>(url, &#123; <span class="hljs-attr">observe</span>: <span class="hljs-string">&#x27;response&#x27;</span>, <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;blob&#x27;</span> &#125;).<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">result: any</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>     <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([result.<span class="hljs-property">body</span>]);<br>     <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">navigator</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">navigator</span>.<span class="hljs-property">msSaveBlob</span>) &#123;<br>       <span class="hljs-comment">// 如果是 IE11，使用 msSaveBlob 方法触发下载</span><br>       <span class="hljs-variable language_">window</span>.<span class="hljs-property">navigator</span>?.<span class="hljs-title function_">msSaveBlob</span>(blob, name);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 其他浏览器，使用传统的创建链接方式</span><br>       <span class="hljs-keyword">const</span> newUrl = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);<br>       <span class="hljs-keyword">const</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>       link.<span class="hljs-property">href</span> = newUrl;<br>       link.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;download&#x27;</span>, name);<br>       <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(link);<br>       link.<span class="hljs-title function_">click</span>();<br>       <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(link);<br>       <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(newUrl);<br>     &#125;<br>   &#125;);<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂文件上传</title>
    <link href="/2024/07/09/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/07/09/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>前端如何将文件发送至服务器，是用什么格式的数据进行传输？Blob、File、FileReader、Base64 等概念都有何关联？</p><span id="more"></span><p><img src="pic1.jpeg" title="文件相关概念关系" width="600px"></img></p><h1 id="1-Blob"><a href="#1-Blob" class="headerlink" title="1.Blob"></a>1.Blob</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Blob 全称为 binary large object ，即二进制大对象。blob 对象本质上是 js 中的一个对象，里面可以储存大量的二进制编码格式的数据。Blob 对象一个不可修改，从 Blob 中读取内容的唯一方法是使用 FileReader。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>(array, type);<br></code></pre></td></tr></table></figure><p><strong>array</strong>：由 ArrayBuffer、ArrayBufferView、Blob、DOMString 等对象构成的，将会被放进 Blob；<br><strong>options</strong>:指定两个属性（均可选）</p><ul><li>type:默认值为””,规定了放在在 blob 内的 MIME 类型。</li><li>endings:默认为”transparent”，用于指定包含行结束符\n 的字符串如何被写入，不常用。</li></ul><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-string">&quot;hello kangaroo&quot;</span>], &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text/plain&quot;</span> &#125;);<br></code></pre></td></tr></table></figure><p><img src="pic2.jpeg" title="执行示例" width="500px"></img></p><h1 id="2-FileReader"><a href="#2-FileReader" class="headerlink" title="2. FileReader"></a>2. FileReader</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>FileReader 是 HTML5 File 中的对象，它允许在客户端对用户选择的文件进行异步读取。使用 FileReader，我们可以读取用户的文件，并基于其内容执行各种操作，如预览图片、读取文本文件等。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>实例方法</th><th>说明</th></tr></thead><tbody><tr><td>abort()</td><td>中止读取操作。在返回时，readyState 属性为 DONE。</td></tr><tr><td>readAsArrayBuffer(file)</td><td>读取文件并将其内容解读为二进制数据的 ArrayBuffer 对象。</td></tr><tr><td>readAsBinaryString(file)</td><td>读取文件并将其内容解读为二进制字符串。</td></tr><tr><td>readAsDataURL(file)</td><td>读取文件并将其内容解读为一个 base64 编码的数据 URL。</td></tr><tr><td>readAsText(file,[encoding])</td><td>读取文件并将其内容解读为纯文本。encoding 参数是可选的，表示文本的编码。</td></tr></tbody></table><h2 id="上传图片预览案例"><a href="#上传图片预览案例" class="headerlink" title="上传图片预览案例"></a>上传图片预览案例</h2><div><!-- <form method = "post" action="http://localhost/test" enctype="multipart/form-data"> --><input type="file" name="file" id="test-image-file"><!-- </form> --><p>图片预览</p><div id="test-image-preview" style="border: 1px solid rgb(204, 204, 204);    width: 100%;    height: 200px;    background-size: contain;    background-repeat: no-repeat;    background-position: center center;"></div></form><span id="test-file-info"></span></div><script>var fileInput = document.getElementById('test-image-file')var info = document.getElementById('test-file-info')var preview = document.getElementById('test-image-preview')//监听change事件fileInput.addEventListener('change',function(){    //清除背景图片    preview.style.backgroundImage = '';    //检查文件是否已选择    if(!fileInput.value){        info.innerHTML = '没有选择文件'        console.log("切换文件")    }    //获取File引用    var file = fileInput.files[0]    //获取File信息    info.innerHTML = '文件：'+file.name +'<br>'+                     '大小：'+file.size +'<br>'+                     '修改'+ file.lastModified    if(file.type!=='image/jpeg' && file.type!=='image/png' && file.type!=='image/gif'){        alert('不是有效的图片文件！')        return;    }    //读取文件    var reader = new FileReader();    reader.onload = function(e){        var data = e.target.result;        preview.style.backgroundImage = 'url(' + data + ')' // 'data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...'    }    reader.readAsDataURL(file)})</script><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test-image-file&quot;</span>),<br>  info = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test-file-info&quot;</span>),<br>  preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;test-image-preview&quot;</span>);<br><span class="hljs-comment">// 监听change事件:</span><br>fileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 清除背景图片:</span><br>  preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-comment">// 检查文件是否选择:</span><br>  <span class="hljs-keyword">if</span> (!fileInput.<span class="hljs-property">value</span>) &#123;<br>    info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;没有选择文件&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 获取File引用:</span><br>  <span class="hljs-keyword">var</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-comment">// 获取File信息:</span><br>  info.<span class="hljs-property">innerHTML</span> =<br>    <span class="hljs-string">&quot;文件: &quot;</span> +<br>    file.<span class="hljs-property">name</span> +<br>    <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>    <span class="hljs-string">&quot;大小: &quot;</span> +<br>    file.<span class="hljs-property">size</span> +<br>    <span class="hljs-string">&quot;&lt;br&gt;&quot;</span> +<br>    <span class="hljs-string">&quot;修改: &quot;</span> +<br>    file.<span class="hljs-property">lastModified</span>;<br>  <span class="hljs-keyword">if</span> (<br>    file.<span class="hljs-property">type</span> !== <span class="hljs-string">&quot;image/jpeg&quot;</span> &amp;&amp;<br>    file.<span class="hljs-property">type</span> !== <span class="hljs-string">&quot;image/png&quot;</span> &amp;&amp;<br>    file.<span class="hljs-property">type</span> !== <span class="hljs-string">&quot;image/gif&quot;</span><br>  ) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;不是有效的图片文件!&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 读取文件</span><br>  <span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();<br>  <span class="hljs-comment">//设置fileReader异步操作回调函数</span><br>  reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">var</span> data = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;</span><br>    preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&quot;url(&quot;</span> + data + <span class="hljs-string">&quot;)&quot;</span>;<br>  &#125;;<br>  <span class="hljs-comment">// 以DataURL的形式读取文件:</span><br>  reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="3-base64"><a href="#3-base64" class="headerlink" title="3.base64"></a>3.base64</h1><p>Base64 是常见的用于传输 8Bit 字节码的编码方式之一，基于 64 个可打印字符来标识二进制数据点方法。</p><p>在 JavaScript 中，有两个函数被分别用来处理解码和编码 base64 字符串：</p><p>atob()：解码，解码一个 Base64 字符串；</p><p>btoa()：编码，从一个字符串或者二进制数据编码一个 Base64 字符串。</p><p>记忆：字母表顺序从高到低，a-&gt;b 是解码，从低到高，b-&gt;a 是编码</p><blockquote><p><a href="https://blog.csdn.net/qq_38157825/article/details/124251372">认识 Base64，看这篇足够了</a></p></blockquote><h1 id="4-大文件上传"><a href="#4-大文件上传" class="headerlink" title="4.大文件上传"></a>4.大文件上传</h1><p>上传大型文件时，可能会因为如下原因产生文件上传中断。</p><ol><li>文件上传超时。原因是前端请求框架默认限制最大请求时长，或者是 nginx（或其他代理&#x2F;网管）限制了最大请求时长。</li><li>文件大小超限。原因在于后端对单个请求大小做了限制，一般 nginx 和 server 都会做这个限制。</li><li>上传耗时久。</li><li>由于各种网络原因上传失败，且失败之后需要从头开始。</li></ol><h2 id="4-1-分片上传"><a href="#4-1-分片上传" class="headerlink" title="4.1 分片上传"></a>4.1 分片上传</h2><h3 id="4-1-2-文件分片"><a href="#4-1-2-文件分片" class="headerlink" title="4.1.2 文件分片"></a>4.1.2 文件分片</h3><p>其中，start 和 end 代表 blob 里的下标，contentType 表示分片后生成文件的文档类型（很少使用）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> blob = instanceOfBlob.<span class="hljs-title function_">slice</span>([start,[,end[,contentType]]])<br></code></pre></td></tr></table></figure><h3 id="4-1-2-文件合并"><a href="#4-1-2-文件合并" class="headerlink" title="4.1.2 文件合并"></a>4.1.2 文件合并</h3><p>文件合并文件合并方案有这么几种。</p><ol><li>前端发送切片完成后，发送一个合并请求，后端收到请求后，将之前上传的切片文件合并。</li><li>后台记录切片文件上传数据，当后台检测到切片上传完成后，自动完成合并。</li><li>创建一个和源文件大小相同的文件，根据切片文件的起止位置直接将切片写入对应位置。<br>这三种方案中，前两种都是比较通用的方案，且都是可行的，方案一的代价在于多发了一次请求，极小的概率会出现文件上传成功，但是合并请求发送失败的情况，好处就是流程比较清晰。方案二比方案一少了一次请求，代价是每次上传结束后需要判断当前切片是否是最后一个切片，需要在数据库中维护切片的状态。</li></ol><p>方案三比较好的，相当于直接省略了文件合并的步骤，速度比较快。但是不用语言的实现难度不同。如果没有合适的 API 的话，自己实现的难度很大。</p><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><h1 id="获取文件上传进度"><a href="#获取文件上传进度" class="headerlink" title="获取文件上传进度"></a>获取文件上传进度</h1><p>XMLHttpRequest提供了事件progress，会在请求收到数据的时候被周期性触发，返回文件已上传的大小和总大小，用于检测文件上传进度。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696">廖雪峰——操作文件</a></li><li><a href="https://www.bilibili.com/video/BV1XD4y1C7S3/?spm_id_from=333.788&vd_source=2ada3c3412abaaf575e01bcac9bbc6f2">视频：今天一次性给你讲清楚：File、Blob、FileReader、ArrayBuffer、Base64</a></li><li><a href="https://mp.weixin.qq.com/s/af-F2goqnfMEo_yT_yFUMw">大规格文件的上传优化</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>短信校验码组件</title>
    <link href="/2024/07/09/%E7%9F%AD%E4%BF%A1%E6%A0%A1%E9%AA%8C%E7%A0%81%E7%BB%84%E4%BB%B6/"/>
    <url>/2024/07/09/%E7%9F%AD%E4%BF%A1%E6%A0%A1%E9%AA%8C%E7%A0%81%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>点击获取短信时，需要先输入正确的图片校验码，防止自动化攻击。会涉及关于 Blob 文件、FileReader 等方面的知识点。</p><span id="more"></span><p><img src='pic1.jpeg' title="图片校验码" width="300px"></img></p><h1 id="相关基础知识"><a href="#相关基础知识" class="headerlink" title="相关基础知识"></a>相关基础知识</h1><h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><p><a href="https://blog.csdn.net/weixin_57208584/article/details/135537236">Blob 详解</a></p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><h2 id="ngrx"><a href="#ngrx" class="headerlink" title="ngrx"></a>ngrx</h2><p><a href="https://ngrx.io/docs">ngrx 官网</a><br><a href="https://cn.redux.js.org/introduction/getting-started">Redux</a></p><p>Rxjs</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>运行项目时踩的一些坑（管理工具相关）</title>
    <link href="/2024/07/08/%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%B8%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <url>/2024/07/08/%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%B8%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>因为不同项目使用不同 node 版本和包管理工具(yarn,pnpm,npm)，更改全局配置后导致项目无法运行，折腾了一天，才发现可能是一些基础性的使用问题，特此记录一下。</p><span id="more"></span><h1 id="1-管理工具总结"><a href="#1-管理工具总结" class="headerlink" title="1.管理工具总结"></a>1.管理工具总结</h1><h2 id="1-1-Homebrew"><a href="#1-1-Homebrew" class="headerlink" title="1.1 Homebrew"></a>1.1 Homebrew</h2><p><a href="https://brew.sh/zh-cn/">官方网站</a></p><blockquote><p>为什么有 brew，因为 mac 平台的 appstore 非常的不好用，审核也很严，因此有很多一些大家公认的“正版”好用的软件，都会在 homebrew 发布，例如 openjdk、qq、maven、go 等，它是 Mac OSX 上的软件包管理工具，能够使用命令行实现安装、卸载、升级的功能。类似 ubuntu 系统下的 apt-get 的功能。<br>而且很多软件都推荐使用 brew 安装，因为它可以帮助你解决安装依赖问题，例如你想下载 go、maven 这种命令行工具，你还需要配置其它的一些环境，而 brew 在安装的时候都帮你配置好了。</p></blockquote><ul><li><a href="https://juejin.cn/post/6847902225092575245">5 分钟白嫖我常用的免费效率软件&#x2F;工具!效率 300% up!</a></li></ul><p>brew 的常见 CLI 命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">//安装指定包</span><br>brew install xxx<br><br><span class="hljs-comment">//卸载指定包</span><br>brew uninstall xxx<br></code></pre></td></tr></table></figure><h2 id="1-2-NVM"><a href="#1-2-NVM" class="headerlink" title="1.2 NVM"></a>1.2 NVM</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，让 JavaScript 可以在服务器端运行，同时也是一个强大的工具，可用于开发各种类型的网络应用程序。</p><p>不同的项目通常会使用不同版本的 Node.js，如何对不同版本的 node 进行管理呢，答案是使用 nvm。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//安装指定版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> install v16<br>nvm install <span class="hljs-number">16</span><br><br>//切换当前使用的<span class="hljs-keyword">node</span><span class="hljs-title">版本</span><br><span class="hljs-title">nvm</span> use v16<br><br>//查看已经安装的<span class="hljs-keyword">node</span><span class="hljs-title">版本列表</span><br><span class="hljs-title">nvm</span> ls<br><br>//卸载指定版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> uninstall v16<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//查看当前<span class="hljs-keyword">node</span><span class="hljs-title">版本</span><br><span class="hljs-title">node</span> -v<br></code></pre></td></tr></table></figure><p>切换 node 版本后，全局安装包时，会安装到对应 node 版本目录下。也就是说，可以在 node16 和 node20 下分别下载 npm 而互不影响。</p><blockquote><p>如果你切换到不同的 Node.js 版本（例如从 Node.js v12 切换到 Node.js v14），然后执行 <code>npm install -g yarn</code>，那么 yarn 将会安装到当前选定的 Node.js 版本的全局环境中，而不会影响其他 Node.js 版本的全局环境。<br>每个 Node.js 版本的全局环境是相互独立的，因此你可以在不同的 Node.js 版本下安装和使用不同版本的 yarn。</p></blockquote><h2 id="1-3-包管理工具"><a href="#1-3-包管理工具" class="headerlink" title="1.3 包管理工具"></a>1.3 包管理工具</h2><p>主要使用过的包管理工具有 npm ,yarn ,pnpm，这次尝试使用了 node 出的实验性功能 corepack，引发了一系列的问题。</p><p>npm 常用操作</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>安装依赖<br>npm install -g pnpm@latest<br><br><span class="hljs-string">//</span>清理缓存（需确认清除操作）<br>npm cache <span class="hljs-keyword">clear</span><br><br><span class="hljs-string">//</span>强制清理全部缓存（无需确认）<br>pnpm cache clean <span class="hljs-params">--force</span><br><br><span class="hljs-string">//</span>查看缓存中安装的包<br>npm cache <span class="hljs-keyword">ls</span><br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>查看pnpm版本<br>pnpm -v<br><br><span class="hljs-regexp">//</span>安装最新pnpm<br>pnpm install pnpm -g<br><br><span class="hljs-regexp">//</span>查看pnpm安装路径<br>which pnpm<br><br><span class="hljs-regexp">//</span>卸载pnpm（使用npm进行全局安装时）<br>npm uninstall pnpm -g<br><br><span class="hljs-regexp">//</span>卸载pnpm(使用brew安装时)<br>brew uninstall pnpm<br><br><span class="hljs-regexp">//</span>卸载pnpm（使用普通方法无法卸载干净时，直接删除which pnpm指向的文件目录）<br><span class="hljs-regexp">//</span>比如使用which pnpm得到的路径为<span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/opt/</span>node@<span class="hljs-number">16</span><span class="hljs-regexp">/bin/</span>pnpm<br>rm <span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/opt/</span>node@<span class="hljs-number">16</span><span class="hljs-regexp">/bin/</span>pnpm<br><br><br><span class="hljs-regexp">//</span>或者使用rm -rf进行强制删除，不进行信息提示，注意防止误删<br>rm -rf <span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/opt/</span>node@<span class="hljs-number">16</span><span class="hljs-regexp">/bin/</span>pnpm<br><br></code></pre></td></tr></table></figure><p>注意：用什么方式下载就要用什么卸载，比如我分别执行如下命令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>pnpm<br>pnpm <span class="hljs-keyword">install </span>pnpm -g<br></code></pre></td></tr></table></figure><p>再执行<code>pnpm uninstall pnpm</code>后，执行<code>pnpm -v</code>，pnpm 仍存在，因为<code>pnpm uninstall pnpm</code>无法卸载 brew 目录下的 pnpm。</p><h1 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2.环境变量配置"></a>2.环境变量配置</h1><h2 id="2-1-zsh-添加全局-PATH"><a href="#2-1-zsh-添加全局-PATH" class="headerlink" title="2.1 zsh 添加全局 PATH"></a>2.1 zsh 添加全局 PATH</h2><p>有多个环境变量配置文件。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/etc/paths</span><br><span class="hljs-string">/etc/profile</span> <span class="hljs-string">//</span>存在时，不会下载下述文件<br>~<span class="hljs-string">/.bash_profile</span><br>~<span class="hljs-string">/.bash_login</span><br>~<span class="hljs-string">/.profile</span><br>~<span class="hljs-string">/.bashrc</span><br></code></pre></td></tr></table></figure><p>&#x2F;etc&#x2F;profile 和 &#x2F;etc&#x2F;paths 是系统级别的配置文件，后面几个是用户级的配置文件。</p><p>zsh shell 的环境变量配置文件为</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>系统环境变量<br>~<span class="hljs-string">/.zshenv</span><br><span class="hljs-string">//</span>用户环境变量配置文件<br>~<span class="hljs-string">/.zshrc</span><br></code></pre></td></tr></table></figure><p>解决环境变量在 zsh shell 无效的问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>打开 zsh shell 时会顺序加载 <code>~/.zshenv</code>、<code>~/.zshrc</code> 文件，添加上面两条命令语句，则表示加载 <code>~/.zshenv</code> 或 <code>~/.zshrc</code> 时会去调用外部脚本文件 <code>/etc/profile</code> 和 <code>~/.bash_profiel</code>，且被调用的脚本运行结束后，所拥有的环境变量和声明变量会被当前 zsh shell 保留，类似将调用脚本的内容复制过来直接执行，执行完毕后原主 shell 继续运行。所以通过这样的方式就可以使用在 bash shell 环境下配置的环境变量了。</p><p>当然你也可以直接将相关的环境变量配置在 ~&#x2F;.zshrc 文件中，但是显然是多余而且繁琐了，每次你要新增一个环境变量的时候，你都要在 bash shell 有关的配置文件中添加，又要在 zsh shell 有关的配置文件中添加，显然是不合适的。而如果每次加载 ~&#x2F;.zshrc 文件时会自动调用 bash shell 有关的配置文件，那么所有的环境变量只要在 bash shell 有关的配置文件中添加就可以了。</p><p><span style="background-color:yellowgreen">碎碎念：</span>我基本都使用 zsh，所以只修改～&#x2F;.zshrc 也是可以的</p><blockquote><p><a href="https://blog.csdn.net/liaowenxiong/article/details/112180532">macOS 下配置环境变量&#x2F;查看环境变量</a></p></blockquote><h2 id="2-2-常用-Linux-命令"><a href="#2-2-常用-Linux-命令" class="headerlink" title="2.2 常用 Linux 命令"></a>2.2 常用 Linux 命令</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//查看系统变量</span><br><span class="hljs-keyword">export</span><br></code></pre></td></tr></table></figure><p>编辑系统环境变量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 编辑<span class="hljs-regexp">/etc/</span>profile中的环境变量<br>sudo vim <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>编辑用户环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bash_profile<br>vim ~/.zshrc<br></code></pre></td></tr></table></figure><p><span style="background-color:yellowgreen">关联知识：</span><br>sudo: 是一个命令，用于以超级用户的身份（也称为 root 用户）来执行后面的命令。它通常用于执行需要管理员权限的操作，比如修改系统配置文件或安装软件包等。</p><p>vim: 是一个文本编辑器程序，类似于 Unix&#x2F;Linux 系统中常用的编辑器之一，其特点是功能强大但学习曲线较陡。它可以用来编辑文本文件，包括配置文件、代码文件等。</p><h1 id="3-问题记录及解决方法"><a href="#3-问题记录及解决方法" class="headerlink" title="3.问题记录及解决方法"></a>3.问题记录及解决方法</h1><h2 id="3-1-无法用-yarn-启动项目"><a href="#3-1-无法用-yarn-启动项目" class="headerlink" title="3.1 无法用 yarn 启动项目"></a>3.1 无法用 yarn 启动项目</h2><p><img src="/2024/07/08/%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%B8%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/pic1.png" alt="无法用yarn启动项目" title="无法用yarn启动项目"></p><p>前置说明：当前项目使用 node16，yarn 进行管理，但是在安装 corepack 后<code>pnpm install corepack -g</code>，导致无法使用 yarn 启动项目。</p><p>解决方法：</p><ul><li>卸载 corepack，如果未卸载干净，则使用 <code>which corepack</code>查看 corepack 的安装路径，删除对应文件夹。</li><li>在 package.json 里配置 packageManager 为 yarn</li></ul><p><img src="/2024/07/08/%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%B8%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/pic3.jpeg" alt="项目配置包管理工具" title="项目配置包管理工具"></p><h3 id="3-2-什么是-corepack"><a href="#3-2-什么是-corepack" class="headerlink" title="3.2 什么是 corepack"></a>3.2 什么是 corepack</h3><blockquote><p>Corepack 是一个基于 Pika 的项目，旨在为 JavaScript 开发者提供一个更快速、更简洁的包管理器。它的目标是解决 npm 和 Yarn 在性能和用户体验方面的一些问题，并且采用了一些新的方法来提升包管理器的效率和可靠性。<br>Corepack 的特点包括：<br>快速安装速度：Corepack 使用预编译二进制文件来加快包的安装速度，这种方法可以显著减少安装时间和网络带宽的消耗。<br>简化的命令行接口：Corepack 提供了一组简洁而一致的命令行工具，使得开发者可以更轻松地管理依赖关系。<br>可插拔的架构：Corepack 的架构允许开发者通过插件来扩展和定制其功能，以满足特定的需求或集成到特定的开发工作流中。<br>良好的兼容性：Corepack 兼容 npm 和 Yarn 的包描述文件格式（如 package.json），并且可以直接在现有的 JavaScript 项目中使用，无需修改项目文件结构。<br>透明且可靠的缓存管理：Corepack 提供了强大的缓存管理机制，可以帮助开发者更有效地利用本地和远程的包缓存，从而进一步提升安装和构建的效率。<br>总体来说，Corepack 旨在通过创新的技术和简化的用户体验，为 JavaScript 开发者提供更好的包管理解决方案。</p></blockquote><p>因此 corepack 可能会与 yarn 产生冲突，导致无法使用 yarn 启动项目。</p><ul><li><span style="background-color:yellowgreen">能否有一种方法在安装 corepack 的情况下，还使用 yarn 启动项目？（待调研）</span></li></ul><h2 id="3-3-无法找到对应-PATH"><a href="#3-3-无法找到对应-PATH" class="headerlink" title="3.3 无法找到对应 PATH"></a>3.3 无法找到对应 PATH</h2><p><img src="/2024/07/08/%E8%BF%90%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%B8%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/pic2.png" alt="无法找到对应路径" title="无法找到对应路径"></p><p>按照上文添加 PATH 的方法，将指定路径添加到全局 PATH 中即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>管理端input通用组件封装</title>
    <link href="/2024/07/02/%E7%AE%A1%E7%90%86%E7%AB%AF%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"/>
    <url>/2024/07/02/%E7%AE%A1%E7%90%86%E7%AB%AF%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>大佬不愧是大佬，三年前写的通用组件我们到现在都还在用，扒拉一下，好好学习学习。</p><span id="more"></span><p>在管理端，经常需要输入 ip&#x2F;MAC 地址作为搜索条件进行搜索，如果在每个业务组件中都进行重复的格式判别和转换，将非常繁琐。因此，封装可复用的输入类型组件就非常必要了。</p><p>主要的类型有：</p><ol><li>普通输入</li></ol><ul><li>ipv4&#x2F;ipv6 地址输入框</li><li>mac 地址输入框</li><li>数字范围输入框</li><li>树选择器</li></ul><ol start="2"><li>含匹配规则的输入</li></ol><ul><li>ipv4&#x2F;ipv6：等于、不等于、大于等于、小于、小于等于、至、包含</li><li>mac：等于、不等于、包含</li><li>设备端口：等于、不等于、包含、正则</li></ul><h1 id="1-ipv4-格式输入框"><a href="#1-ipv4-格式输入框" class="headerlink" title="1 ipv4 格式输入框"></a>1 ipv4 格式输入框</h1><p>ipv4 格式输入框：<app-ipv4-input></p><h2 id="1-1-使用方法"><a href="#1-1-使用方法" class="headerlink" title="1.1 使用方法"></a>1.1 使用方法</h2><p>调用组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-ipv4-input</span></span><br><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%&quot;</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">value</span>]=<span class="hljs-string">&quot;params.value&quot;</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;params.il8n&quot;</span></span><br><span class="hljs-tag">  (<span class="hljs-attr">inputChange</span>)=<span class="hljs-string">&quot;params.value = $event&quot;</span></span><br><span class="hljs-tag">  (<span class="hljs-attr">ipCheckResult</span>)=<span class="hljs-string">&quot;xxx&quot;</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">forAdvanceSearch</span>]=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-ipv4-input</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用ipCheckResult判别是否显示错误校验 --&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-2-组件属性方法"><a href="#1-2-组件属性方法" class="headerlink" title="1.2 组件属性方法"></a>1.2 组件属性方法</h2><p>自定义 input 组件，应该能够实现 input 组件的基本方法，并且支持在 form 表单中使用。</p><p>html 属性：</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值&#x2F;绑定值</th></tr></thead><tbody><tr><td>[placeholder]</td><td>input 占位文本</td><td>根据 forAdvanceSearch 判断</td></tr><tr><td>[(ngModel)]</td><td>input 双向绑定值</td><td>组件属性 showipValue</td></tr><tr><td>[disabled]</td><td>input 是否禁用</td><td>disabled</td></tr><tr><td>[class.error]</td><td>是否显示.error 样式</td><td>组件属性 formateError</td></tr><tr><td>[class.ok]</td><td>是否显示.ok 样式（为空）</td><td>组件属性 formateError 取反</td></tr><tr><td>(blur)</td><td>input 失去焦点时，触发的事件</td><td>keyUp()</td></tr><tr><td>(keydown)</td><td>input 在按下按键时触发的事件</td><td>onKeyDown($event)</td></tr></tbody></table><blockquote><p>blur 和 keydown 是原生 input 的事件，继承于 Element 类，Element 是最通用的基类，Document 中所有元素对象（即表示元素的对象）都继承于它。它具有各种元素公共的方法和属性。更具体的类则继承于 Element。<br>例如，HTMLElement 接口是所有 HTML 元素的基本接口。同样，SVGElement 接口是所有 SVG 元素的基本接口，而 MathMLElement 接口则是 MathML 元素的基础接口。大多数功能是在这个类的更深层级的接口中被进一步制定的。</p></blockquote><p>ts 属性：</p><table><thead><tr><th>参数名称</th><th>装饰器&#x2F;类型</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>forAdvanceSearch</td><td>@Input()</td><td>是否为高级搜索（决定了 placehodler 展示的内容）</td><td></td></tr><tr><td>key</td><td>@Input()</td><td>组件的 key 值，并在 placeholder 内显示</td><td>‘input’</td></tr><tr><td>disabled</td><td>@Input()</td><td>是否禁用</td><td>false</td></tr><tr><td>openCheck</td><td>@Input()</td><td>是否开启 ip 校验</td><td>false</td></tr><tr><td>placeholder</td><td>@Input()</td><td>占位文本</td><td>‘请输入’</td></tr><tr><td>nzParser</td><td>@Input()</td><td>格式转换</td><td>value&#x3D;&gt;value</td></tr><tr><td>formatError</td><td>@Input()</td><td>格式错误，用于显示错误格式校验</td><td>false</td></tr><tr><td>nzParser</td><td>@Input()</td><td>格式转换</td><td>value&#x3D;&gt;value</td></tr><tr><td>inputChange</td><td>@Output()</td><td>input 内值发生变化</td><td>new Eventemitter()</td></tr><tr><td>checkResult</td><td>@Output()</td><td>ip 校验结果</td><td>new EventEmitter()</td></tr><tr><td>ipCheckResult</td><td>@Output()</td><td>ip 校验结果</td><td>new EventEmitter()</td></tr></tbody></table><p><strong>⚠️ 注意 ：</strong> checkResult 是在 input 绑定值发生变化时触发，ipCheckResult 是在 input 失去焦点时触发。在使用组件时，checkResult 和 ipcheckResult 都能对输入的 ip 地址进行校验，监听 checkResult 同步更改表单值，监听 ipcheckResult 可以在输入结束失去焦点时对 ip 进行额外判断（比如判别是否在某一可用 ip 段内）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">placeholder</span>]=<span class="hljs-string">&quot;forAdvanceSearch ? (&#x27;input&#x27; | translate) + (placeholder | translate) : (placeholder | translate)&quot;</span></span><br><span class="hljs-tag">  #<span class="hljs-attr">inputElement</span></span><br><span class="hljs-tag">  <span class="hljs-attr">nz-input</span></span><br><span class="hljs-tag">  [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;showipValue&quot;</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">disabled</span>]=<span class="hljs-string">&quot;disabled&quot;</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">class.error</span>]=<span class="hljs-string">&quot;formateError&quot;</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">class.ok</span>]=<span class="hljs-string">&quot;!formateError&quot;</span></span><br><span class="hljs-tag">  (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">&quot;ngModelChangeValue($event)&quot;</span></span><br><span class="hljs-tag">  (<span class="hljs-attr">blur</span>)=<span class="hljs-string">&quot;keyUp()&quot;</span></span><br><span class="hljs-tag">  (<span class="hljs-attr">keydown</span>)=<span class="hljs-string">&quot;onKeyDown($event)&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-3-格式校验及转换"><a href="#1-3-格式校验及转换" class="headerlink" title="1.3 格式校验及转换"></a>1.3 格式校验及转换</h2><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><p>目标：将”123123123”转换成“123.123.123”</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul><li>判断上一个操作的按键是否为清除键”Backspace”，如果是则跳过后续操作。</li><li>去除空格</li><li>中文标点转换为英文标点，”。”&#x3D;&gt;”.”</li><li>标点去重</li><li>去除非数字字符</li><li>格式转换（若未输入”.”，则自动用”.”拼接）</li></ul><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//该函数是(ngModelChange)绑定的事件</span><br><span class="hljs-title function_">ngModelChangeValue</span>(<span class="hljs-params">value:<span class="hljs-built_in">string</span></span>)&#123;<br>  <span class="hljs-comment">//1.判断上一个操作的按键是否为清除键&quot;Backspace&quot;，如果是则仅抛出inputChange事件，跳过后续操作。</span><br>  <span class="hljs-comment">//preEvent在keyDown事件中进行更新</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">preEvent</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">preEvent</span> === <span class="hljs-string">&#x27;Backspace&#x27;</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputChange</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">//修改格式</span><br>  conste temp =<br>  value.<span class="hljs-title function_">trim</span>() <span class="hljs-comment">//2.去除空格</span><br>  .<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;/。/g&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-comment">//3.中文标点转换为英文标点，&quot;。&quot;=&gt;&quot;.&quot;</span><br>  .<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;/(\.)(\1*)/g&#x27;</span>) <span class="hljs-comment">//4.标点去重</span><br>  .<span class="hljs-property">replace</span>（<span class="hljs-string">&#x27;/^\d\./g&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>）<span class="hljs-comment">//5.去除非数字字符</span><br><br>  <span class="hljs-comment">//将处理后的ip地址进行格式转换</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">ips</span>:<span class="hljs-built_in">string</span>[] = temp.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">v,index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> index &lt;= <span class="hljs-number">3</span>;<br>  &#125;)<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span> ; k &lt; ips.<span class="hljs-property">length</span> ; k++)&#123;<br>    conste te = ips[k].<span class="hljs-title function_">substr</span>(<span class="hljs-number">3</span>)<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; ips.<span class="hljs-property">length</span>; k++)&#123;<br>      <span class="hljs-keyword">const</span> te = ips[k].<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>      <span class="hljs-keyword">if</span> (k &lt; ips.<span class="hljs-property">length</span> -<span class="hljs-number">1</span> || (te.<span class="hljs-property">length</span> ===<span class="hljs-number">3</span> &amp;&amp; k!==<span class="hljs-number">3</span>)) &#123;<br>        result += (te +<span class="hljs-string">&#x27;.&#x27;</span>)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        result += te<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//更新input组件值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputElement</span>.<span class="hljs-property">nativeElement</span>.<span class="hljs-property">value</span> = reault;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">showipValue</span> = result;<span class="hljs-comment">//还必须要修改组件的值，但是已经有ngModel了为什么没生效</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputChange</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-ipv4-格式范围选择输入框"><a href="#2-ipv4-格式范围选择输入框" class="headerlink" title="2 ipv4 格式范围选择输入框"></a>2 ipv4 格式范围选择输入框</h1><img src="ipv4-range.jpg" width="400" title="ipv4-range组件"/><p>ts 属性：</p><table><thead><tr><th>参数名称</th><th>装饰器&#x2F;类型</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>inputModel</td><td>@Input()</td><td>绑定模型</td><td></td></tr><tr><td>operatorMap</td><td>@Input()</td><td>操作下拉列表</td><td></td></tr><tr><td>ipv4ValueEmit</td><td>@Output()</td><td>参数值发生变化时触发</td><td></td></tr></tbody></table><h2 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-ipv4-range</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">operatorMap</span>]=<span class="hljs-string">&quot;operatorMap&quot;</span></span><br><span class="hljs-tag">  [<span class="hljs-attr">inputModel</span>]=<span class="hljs-string">&quot;params&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;width-100&quot;</span></span><br><span class="hljs-tag">  (<span class="hljs-attr">ipv4ValueEmit</span>)=<span class="hljs-string">&quot;paramValueChange($event, ci, pi)&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-ipv4-range</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 paramValueChange 中，将组件内容更新至表单项。<br>相关的下拉框配置、提交表格前的字符串拼接，均在调用<app-ipv4-rang>的组件中实现。</p><h2 id="2-1-关键代码"><a href="#2-1-关键代码" class="headerlink" title="2.1 关键代码"></a>2.1 关键代码</h2><h3 id="模板内容"><a href="#模板内容" class="headerlink" title="模板内容"></a>模板内容</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">nz-row</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div-vertical-middle&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;operate-cond&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nz-select</span></span><br><span class="hljs-tag">      [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;inputModel.operator&quot;</span></span><br><span class="hljs-tag">      (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">&quot;valueChange($event, null)&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">nz-option</span></span><br><span class="hljs-tag">        *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let op of operatorMap&quot;</span></span><br><span class="hljs-tag">        [<span class="hljs-attr">nzLabel</span>]=<span class="hljs-string">&quot;op.name&quot;</span></span><br><span class="hljs-tag">        [<span class="hljs-attr">nzValue</span>]=<span class="hljs-string">&quot;op.value&quot;</span></span><br><span class="hljs-tag">      &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nz-option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">nz-select</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ng-container</span> [<span class="hljs-attr">ngSwitch</span>]=<span class="hljs-string">&quot;inputModel.operator&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 选择ip段 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;至&#x27;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;div-vertical-middle match-expr-cond&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">nz-col</span> <span class="hljs-attr">nzSpan</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">app-ipv4-input</span></span><br><span class="hljs-tag">          <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: left&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;width-100&quot;</span></span><br><span class="hljs-tag">          [<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;inputModel.il8n&quot;</span></span><br><span class="hljs-tag">          [<span class="hljs-attr">value</span>]=<span class="hljs-string">&quot;inputModel.valueFrom&quot;</span></span><br><span class="hljs-tag">          [<span class="hljs-attr">forAdvanceSearch</span>]=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">          (<span class="hljs-attr">inputChange</span>)=<span class="hljs-string">&quot;valueChange($event, &#x27;valueFrom&#x27;)&quot;</span></span><br><span class="hljs-tag">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-ipv4-input</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">nz-col</span> <span class="hljs-attr">nzSpan</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: center; line-height: 32px&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-white&quot;</span>&gt;</span>至<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">nz-col</span> <span class="hljs-attr">nzSpan</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">app-ipv4-input</span></span><br><span class="hljs-tag">          <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: left&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;width-100&quot;</span></span><br><span class="hljs-tag">          [<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;inputModel.il8n&quot;</span></span><br><span class="hljs-tag">          [<span class="hljs-attr">value</span>]=<span class="hljs-string">&quot;inputModel.valueTo&quot;</span></span><br><span class="hljs-tag">          [<span class="hljs-attr">forAdvanceSearch</span>]=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">          (<span class="hljs-attr">inputChange</span>)=<span class="hljs-string">&quot;valueChange($event, &#x27;valueTo&#x27;)&quot;</span></span><br><span class="hljs-tag">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-ipv4-input</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 包含 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;in&#x27;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;match-expr-cond&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">        <span class="hljs-attr">nz-input</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;width-100&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;&#123;&#123; &#x27;input&#x27; | translate &#125;&#125;&#123;&#123; inputModel.il8n | translate &#125;&#125;&quot;</span></span><br><span class="hljs-tag">        [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;inputModel.value&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 不包含 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;nin&#x27;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;match-expr-cond&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">        <span class="hljs-attr">nz-input</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;width-100&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;&#123;&#123; &#x27;input&#x27; | translate &#125;&#125;&#123;&#123; inputModel.il8n | translate &#125;&#125;&quot;</span></span><br><span class="hljs-tag">        [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;inputModel.value&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 正则 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;&#x27;matches&#x27;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;match-expr-cond&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span><br><span class="hljs-tag">        <span class="hljs-attr">nz-input</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;width-100&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;&#123;&#123; &#x27;input&#x27; | translate &#125;&#125;&#123;&#123; inputModel.il8n | translate &#125;&#125;&quot;</span></span><br><span class="hljs-tag">        [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;inputModel.value&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 默认情况 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngSwitchDefault</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;match-expr-cond&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">app-ipv4-input</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%&quot;</span></span><br><span class="hljs-tag">        *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;inputModel.operator !== &#x27;至&#x27;&quot;</span></span><br><span class="hljs-tag">        [<span class="hljs-attr">value</span>]=<span class="hljs-string">&quot;inputModel.value&quot;</span></span><br><span class="hljs-tag">        [<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;inputModel.il8n&quot;</span></span><br><span class="hljs-tag">        [<span class="hljs-attr">forAdvanceSearch</span>]=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        (<span class="hljs-attr">inputChange</span>)=<span class="hljs-string">&quot;valueChange($event, &#x27;value&#x27;)&quot;</span></span><br><span class="hljs-tag">      &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-ipv4-input</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ng-container</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="ts-关键代码"><a href="#ts-关键代码" class="headerlink" title="ts 关键代码"></a>ts 关键代码</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//inputValue变化时触发事件</span><br> <span class="hljs-title function_">valueChange</span>(<span class="hljs-params">event, <span class="hljs-keyword">type</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;value&#x27;</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputModel</span>.<span class="hljs-property">value</span> = event;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;valueFrom&#x27;</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputModel</span>.<span class="hljs-property">valueFrom</span> = event;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;valueTo&#x27;</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputModel</span>.<span class="hljs-property">valueTo</span> = event;<br>    &#125;<br>    <span class="hljs-comment">//向外抛出事件ipv4ValueEmit</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ipv4ValueEmit</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputModel</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>难点：</p><ul><li>实现可与 form 表单绑定的 input 业务组件，需要能够实现格式校验和格式转换。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>倒计时</title>
    <link href="/2024/07/01/%E5%80%92%E8%AE%A1%E6%97%B6/"/>
    <url>/2024/07/01/%E5%80%92%E8%AE%A1%E6%97%B6/</url>
    
    <content type="html"><![CDATA[<p>手动实现一个倒计时组件，显示距离 2024 年 10 月 1 日的时间。</p><span id="more"></span><style>     #div1 {      font-size: 50px;      background-color: #b5c685;      color: white;      margin:0 auto;      display:flex;      justify-content:center;    }</style><h1 id="倒计时"><a href="#倒计时" class="headerlink" title="倒计时"></a>倒计时</h1> <div id="div1"></div><script>       const el2 = document.getElementById("div1");      // 目标日期      const target = new Date("2024-10-01T00:00:00");      function updateCountdown() {        const now = new Date();        const timeDifference = target - now;        if (timeDifference <= 0) {          clearInterval(interval);          el2.innerHTML = "倒计时已结束";          return;        }        // 计算天、小时、分钟和秒        const days = Math.floor(timeDifference / (1000 * 60 * 60 * 24));        const hours = Math.floor(          (timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)        );        const minutes = Math.floor(          (timeDifference % (1000 * 60 * 60)) / (1000 * 60)        );        const seconds = Math.floor((timeDifference % (1000 * 60)) / 1000);        // 更新页面内容        el2.innerHTML = `${days} 天 ${hours} 小时 ${minutes} 分钟 ${seconds} 秒`;      }      // 间隔1秒更新一次倒计时      const interval2 = setInterval(updateCountdown, 1000);      // 初始化页面内容      updateCountdown();</script><h1 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> el2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div1&quot;</span>);<br><span class="hljs-comment">// 目标日期</span><br><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&quot;2024-10-01T00:00:00&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateCountdown</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-keyword">const</span> timeDifference = target - now;<br><br>  <span class="hljs-keyword">if</span> (timeDifference &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(interval);<br>    el2.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;倒计时已结束&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 计算天、小时、分钟和秒</span><br>  <span class="hljs-keyword">const</span> days = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(timeDifference / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>));<br>  <span class="hljs-keyword">const</span> hours = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<br>    (timeDifference % (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>)) / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)<br>  );<br>  <span class="hljs-keyword">const</span> minutes = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((timeDifference % (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)) / (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>));<br>  <span class="hljs-keyword">const</span> seconds = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((timeDifference % (<span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)) / <span class="hljs-number">1000</span>);<br><br>  <span class="hljs-comment">// 更新页面内容</span><br>  el2.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;days&#125;</span> 天 <span class="hljs-subst">$&#123;hours&#125;</span> 小时 <span class="hljs-subst">$&#123;minutes&#125;</span> 分钟 <span class="hljs-subst">$&#123;seconds&#125;</span> 秒`</span>;<br>&#125;<br><br><span class="hljs-comment">// 间隔1秒更新一次倒计时</span><br><span class="hljs-keyword">const</span> interval2 = <span class="hljs-built_in">setInterval</span>(updateCountdown, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 初始化页面内容</span><br><span class="hljs-title function_">updateCountdown</span>();<br></code></pre></td></tr></table></figure><h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><ul><li>Date 对象的含义及常见方法使用</li><li>使用毫秒数计算日、小时、分钟、秒的方法</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>业务知识梳理</title>
    <link href="/2024/07/01/%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    <url>/2024/07/01/%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>看到一篇写的很好的文章，讲了只做后台管理的前端人如何提升技术，其中很重要的一点就是要熟悉业务。恰好现在 SMP+ 3.5 的开发正在如火如荼的进行着，就将最近开发的业务多深入了解一下。</p><span id="more"></span><h1 id="1-SMP-3-5-业务概览"><a href="#1-SMP-3-5-业务概览" class="headerlink" title="1.SMP+ 3.5 业务概览"></a>1.SMP+ 3.5 业务概览</h1><p>SMP+ 3.5 是我们公司进行网络安全准入的一款产品，它的主要功能是进行终端安全智能准入和身份安全智能准入。主要分成三个功能模块，分别是进行认证准入的 portal 端，进行后台管理的管理端，以及便于用户进行设备及账号管理的用户自助端。</p><h1 id="2-功能模块及主要业务"><a href="#2-功能模块及主要业务" class="headerlink" title="2.功能模块及主要业务"></a>2.功能模块及主要业务</h1><h2 id="2-1-portal-认证"><a href="#2-1-portal-认证" class="headerlink" title="2.1 portal 认证"></a>2.1 portal 认证</h2><p>Portal 认证（Portal Authentication）是一种通过 Web 页面或特定应用程序进行的认证方法，通常用于公共无线网络或受控访问网络中。它要求用户在能够访问 Internet 或特定资源之前，先通过一个认证门户进行身份验证。</p><p>具体来说，Portal 认证包括以下特征和流程：</p><p>身份验证门户：用户试图连接到网络时，会自动被重定向到一个认证门户网页或应用程序。这个门户会要求用户提供身份验证凭据，如用户名和密码，或其他凭据形式。</p><p>认证流程：用户在认证门户上输入必要的信息（可能还包括接受使用条款等），然后提交。认证门户将验证用户提供的信息的有效性。</p><p>访问控制：一旦认证成功，用户设备会被授予访问网络和 Internet 的权限。这通常通过向用户设备分配临时的访问令牌或认证会话来实现，允许设备在一定时间内自由访问网络资源。</p><p>使用场景：Portal 认证常见于公共 Wi-Fi 网络、大学校园网络、酒店或机场等地的网络访问控制中。它可以确保网络资源仅对经过授权的用户开放，并提供一定程度的安全性和管理能力，例如记录用户登录信息或强制用户重新认证。</p><p>Portal 认证通过这种方式，有效地管理和控制访客和设备对网络资源的访问，同时提供了一定程度的安全性和用户身份验证。</p><h2 id="2-2-用户自助"><a href="#2-2-用户自助" class="headerlink" title="2.2 用户自助"></a>2.2 用户自助</h2><p>用户自助是用户可以访问的界面，用户通过自助端进行账号、设备的管理，涉及的功能如下：</p><ul><li>个人账号：账号绑定与解绑、个人信息修改</li><li>GA 版本相关功能：备案申请、备案申请记录、查看我已备案的设备</li><li>地区调动：申请将当前账号从当前所属地区调入到指定地区，并查看申请记录</li><li>日志查看：我上网的设备、我的上网记录、设备上网记录</li></ul><p>注：我上网的设备指的是使用当前自助端登录账户登录的设备，而设备上网记录指的是当前设备的历史使用记录。</p><h2 id="2-3-管理端"><a href="#2-3-管理端" class="headerlink" title="2.3 管理端"></a>2.3 管理端</h2><p>管理端提供给系统管理员或运维人员使用的界面，用于配置和管理认证系统的各种参数、策略和功能。<br>主要功能：配置认证方式（例如：LDAP、Radius、OAuth 等）、用户和角色管理、设置访问控制策略、监控认证系统运行状态、管理认证服务器等。</p><h1 id="3-管理端业务"><a href="#3-管理端业务" class="headerlink" title="3.管理端业务"></a>3.管理端业务</h1><h2 id="3-1-认证黑名单"><a href="#3-1-认证黑名单" class="headerlink" title="3.1 认证黑名单"></a>3.1 认证黑名单</h2><ol><li>使用场景：用户认证时检测黑名单列表，认证终端匹配上黑名单记录，且该条黑名单记录已启用，并在有效期内禁止入网。</li><li>匹配字段：“用户名、硬盘序列号、用户 IP、用户 MAC、设备 IP、设备端口、SSID 名称、APMAC”，符合其中一个及以上字段的终端，则匹配黑名单规则。</li><li>认证规则：用户名密码、企业微信&#x2F;钉钉、UKEY、SID、ZTO、SMP+二维码认证、自动认证。</li><li>认证黑名单可进行的操作有：查询、高级查询、新增、编辑、删除。</li><li>黑名单添加方式：<ul><li>1、管理员手动添加，通过用户名、磁盘序列号、用户 IP、用户 MAC、设备 IP、SSID 名称、无线 AP MAC 匹配用户</li><li>2、管理员强制踢用户下线后直接将用户加入黑名单</li><li>3、账号密码错误次数超过限制，用户自动加入黑名单</li></ul></li></ol><h2 id="3-2-认证白名单"><a href="#3-2-认证白名单" class="headerlink" title="3.2 认证白名单"></a>3.2 认证白名单</h2><ol><li>使用场景：SMP+对接公司的资产系统，将公司内的终端同步 SMP+认证白名单中，当终端认证时需要检测是否在认证白名单内，保证只有公司资产可以接入网络。</li><li>匹配字段：</li><li>认证规则：用户名密码、企业微信&#x2F;钉钉、UKEY、SID、ZTO、SMP+二维码认证、自动认证。</li><li>白名单添加方式：<br>1、管理员手动添加，通过用户名、磁盘序列号、用户 IP、用户 MAC、设备 IP、SSID 名称、无线 AP MAC 匹配用户。<br>2、管理员 execl 导入，通过用户名、磁盘序列号、用户 IP、用户 MAC、设备 IP、SSID 名称、无线 AP MAC 匹配用户。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown的基本使用方法</title>
    <link href="/2024/06/22/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2024/06/22/markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>好记性不如烂笔头，后续用到 markdown 的次数还很多，记录一下基本的使用方法和案例。</p><span id="more"></span><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><p>要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。例如，添加三个 # 表示创建一个三级标题 (&lt;h3&gt;) (例如：### My Header)。</p><h2 id="可选语法"><a href="#可选语法" class="headerlink" title="可选语法"></a>可选语法</h2><p>可以在标题下增加不限数量的”&#x3D;”或者”-“来标记一级标题和二级标题。<br>如：</p><table><thead><tr><th>｜ markdown 语法</th><th>HTML</th><th>页面效果</th></tr></thead><tbody><tr><td>heading<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</td><td>—–</td><td>——</td></tr><tr><td>heading<br>—–</td><td>—–</td><td>——</td></tr></tbody></table><h1 id="2-段落"><a href="#2-段落" class="headerlink" title="2.段落"></a>2.段落</h1><p>通过中间增加空行，实现换行并区分段落。</p><h1 id="3-换行"><a href="#3-换行" class="headerlink" title="3.换行"></a>3.换行</h1><ul><li>在一行的末尾增加两个或多个空格，然后按回车键，即可创建一个换行。</li><li>或者使用“&lt;&#x2F;br&gt;”换行</li></ul><h1 id="4-强调语法"><a href="#4-强调语法" class="headerlink" title="4.强调语法"></a>4.强调语法</h1><h2 id="4-1-粗体"><a href="#4-1-粗体" class="headerlink" title="4.1 粗体"></a>4.1 粗体</h2><p>在单词前后使用”**“或者”__“实现加粗效果。<br>比如： <strong>加粗</strong> 或者 <strong>加粗</strong> 这部分内容。</p><h2 id="4-2-斜体"><a href="#4-2-斜体" class="headerlink" title="4.2 斜体"></a>4.2 斜体</h2><p>在单词前后使用”*”或者”_“实现加粗效果。<br>比如： *斜体* 或者 <em>斜体</em> 这部分内容。</p><h1 id="5-引用语法"><a href="#5-引用语法" class="headerlink" title="5. 引用语法"></a>5. 引用语法</h1><h2 id="5-1-普通引用"><a href="#5-1-普通引用" class="headerlink" title="5.1 普通引用"></a>5.1 普通引用</h2><p>在引用段落前增加&gt;符号<br>比如：</p><blockquote><p>这是引用段落</p></blockquote><h2 id="5-2-多个段落的引用"><a href="#5-2-多个段落的引用" class="headerlink" title="5.2 多个段落的引用"></a>5.2 多个段落的引用</h2><p>在引用段落中增加前缀为&gt;的空行<br>比如：</p><blockquote><p>这是引用段落 1</p><p>这是引用段落 2</p></blockquote><h2 id="5-3-嵌套块引用"><a href="#5-3-嵌套块引用" class="headerlink" title="5.3 嵌套块引用"></a>5.3 嵌套块引用</h2><p>按照嵌套层级增加&gt;的数量即可<br>比如：</p><blockquote><p>这是嵌套层级 1</p><blockquote><p>这是嵌套层级 2</p><blockquote><p>这是嵌套层级 3</p></blockquote></blockquote></blockquote><h2 id="5-4-列表语法"><a href="#5-4-列表语法" class="headerlink" title="5.4 列表语法"></a>5.4 列表语法</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>以数字开头，小数点结尾。序号不需要完全依照顺序，但是应该以 1.开头<br>比如：</p><ol><li>编号 1</li><li>编号 2</li><li>编号 4</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><h3 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a>在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</p><hr><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>I need to add another paragraph below the second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><hr><h1 id="6-代码语法"><a href="#6-代码语法" class="headerlink" title="6.代码语法"></a>6.代码语法</h1><p>使用反引号标记代码块，反引号后面的为代码的语言类型</p><p>`&#96;&#96; javascript<br>console.log(“这是一段 javascript 代码”)<br>`&#96;&#96;</p><p>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是一段javascript代码&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="7-分隔线语法"><a href="#7-分隔线语法" class="headerlink" title="7.分隔线语法"></a>7.分隔线语法</h1><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">***</span><br><span class="hljs-section">---</span><br><span class="hljs-emphasis">_____</span>_<br></code></pre></td></tr></table></figure><h1 id="8-链接语法"><a href="#8-链接语法" class="headerlink" title="8.链接语法"></a>8.链接语法</h1><p>链接文本放在中括号内，链接地址放在后面的括号中，链接 title 可选，在地址后用空格分隔。</p><p>超链接 Markdown 语法代码：<a href="%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="超链接title">超链接显示名</a></p><p>比如：<a href="http://baidu.com/" title="title为百度">超链接名称为百度</a></p><h2 id="网址和-Email-地址"><a href="#网址和-Email-地址" class="headerlink" title="网址和 Email 地址"></a>网址和 Email 地址</h2><p>使用尖括号<br><a href="http://baidu.com/">http://baidu.com</a></p><h2 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h2><p>强调链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">I love supporting the <span class="hljs-strong">**[<span class="hljs-string">EFF</span>](<span class="hljs-link">https://eff.org</span>)**</span>.<br>This is the <span class="hljs-emphasis">*[<span class="hljs-string">Markdown Guide</span>](<span class="hljs-link">https://www.markdownguide.org</span>)*</span>.<br>See the section on [<span class="hljs-string">`code`</span>](<span class="hljs-link">#code</span>).<br></code></pre></td></tr></table></figure><p>效果：<br>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="#code"><code>code</code></a>.</p><h1 id="9-图片语法"><a href="#9-图片语法" class="headerlink" title="9.图片语法"></a>9.图片语法</h1><p>要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片 Markdown 语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code></p><p>对应的 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图片链接&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片alt&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;图片title&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h1 id="10-转义符语法"><a href="#10-转义符语法" class="headerlink" title="10.转义符语法"></a>10.转义符语法</h1><p>在要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">\* Without <span class="hljs-keyword">the</span> <span class="hljs-literal">backslash</span>, this would be <span class="hljs-keyword">a</span> bullet <span class="hljs-keyword">in</span> <span class="hljs-keyword">an</span> unordered list.<br></code></pre></td></tr></table></figure><p>渲染效果如下：</p><ul><li>Without the backslash, this would be a bullet in an unordered list.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端导航栏吸顶效果开发记录</title>
    <link href="/2024/05/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>在 uniapp 中，如何实现类似于抖音个人中心的效果？包含顶部搜索栏，顶部内容以及下方可吸附的导航栏。</p><span id="more"></span><p>页面结构如图所示：<br><img src="/img/blog/xiding-1.jpg" title="图1-页面内容" width="300px"></p><p>理想的实现效果：<br><img src="/img/blog/xiding-2.jpg" title="图2-理想实现效果" width="300px"></p><h3 id="可能的解决方法及问题"><a href="#可能的解决方法及问题" class="headerlink" title="可能的解决方法及问题"></a>可能的解决方法及问题</h3><ol><li><p>监听页面 scroll 事件，滚动到一定距离后为 tab 栏设置 position:fixed。原生的写法，比较麻烦。</p></li><li><p>尝试使用 position-sticky 实现，但是由于兼容性较差，并且针对上图的布局不能取得很好的效果。</p></li></ol><ul><li>由于顶部有固定的搜索栏，h5 和 app 中的实现方式不同，不同设备下 tab 与顶部的距离不同，需要考虑适配问题。</li><li>为 tab 栏增加 postion:fixed 后，当从下往上滑动至一定高度时，再去除该属性，会出现页面闪烁的情况（此时相当于在原本视图内插入了一个 div）</li></ul><ol start="3"><li>（最终解决方法）使用 uni-app 提供的 u-sticky 组件（其本质仍然是 position: sticky，但是具备更好的兼容性），此时，新的问题又出现了：</li></ol><ul><li>在 tab 栏吸顶状态下，切换分区，发现会丢失吸顶状态</li><li>解决上个问题后，发现切换分区时，新分区会保持和上一个分区相同的浏览位置</li><li>解决上个问题后，发现切换分区后，下方区域 card 紧贴 tab（实际他们之间应该存在一定距离）</li></ul><h3 id="关键方法及代码回顾"><a href="#关键方法及代码回顾" class="headerlink" title="关键方法及代码回顾"></a>关键方法及代码回顾</h3><ol><li>使用<u-sticky>包裹需要吸顶的内容</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">u-sticky</span> <span class="hljs-attr">bgColor</span>=<span class="hljs-string">&quot;#ffffff&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--具体的传参及含义可以参考u-tab的组件说明--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">u-tab</span> <span class="hljs-attr">:fileList</span>=<span class="hljs-string">&quot;fileList&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">u-tab</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">u-sticky</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实际的实现效果：<br><img src="/img/blog/xiding-3.jpg" title="图3-实际实现效果" width="300px"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.cn/post/6844903815041269774?searchId=202406221739536B240A19DE9E9A249AD5">【前端词典】5 种滚动吸顶实现方式的比较[性能升级版]</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端知识体系概览（二）—— 模块化和工程化</title>
    <link href="/2024/03/05/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2024/03/05/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>通过<a href="">前端知识体系概览（一）</a>的学习，也许你已经可以搭建一个比较完整的前端项目，但是对项目结构、模块化、工程化等概念还是不甚清晰，本章将一一讲解。</p><span id="more"></span><h1 id="1-项目结构与目录"><a href="#1-项目结构与目录" class="headerlink" title="1 项目结构与目录"></a>1 项目结构与目录</h1><p>假设现在你已经通过框架创建了一个新的项目，虽然使用不同的框架会导致项目目录的结构和层级有所差异，但他们大体都包含如下内容：</p><ul><li><strong><code>/app</code>：</strong> 存放项目的源代码<ul><li><strong><code>/components</code>：</strong> 存放可复用的组件</li><li><strong><code>/pages</code>：</strong> 存放页面级组件</li><li><strong><code>/assets</code>：</strong> 存放静态资源文件，如图片、字体等</li><li><strong><code>/styles</code>：</strong> 存放样式文件，如 CSS、Sass 等</li><li><strong><code>/utils</code>：</strong> 存放通用工具函数</li></ul></li><li><strong><code>/public</code>或<code>/libs</code>：</strong> 存放公共资源，比如公共组件、全局样式等</li><li><strong><code>/node_modules</code>：</strong> 存放项目依赖的第三方包</li><li><strong><code>/tools</code>：</strong> 存放辅助开发、构建和部署的工具脚本或配置文件</li><li><strong><code>/build</code>或<code>/dist</code>：</strong> 存放构建、打包处理后最终生成的静态文件</li><li><strong><code>/readme.md</code>：</strong> 项目的说明文件</li><li><strong><code>package.json</code>或<code>yarn.lock</code>：</strong> 项目的配置文件，包含依赖信息、脚本命令等</li><li><strong><code>webpack.config.js</code>或<code>babel.config.js</code>:</strong> 构建工具配置文件，用于配置项目的构建流程和打包流程</li></ul><p>从目录看，所涉及的知识点有：</p><ul><li><strong>框架的核心理念和实现方法</strong>：把写代码想像成搭房子，学会框架和基础知识的的使用方法就是拥有了建材和基础的瓦匠工技能。</li><li><strong>组件化、模块化</strong>：学习如何搭建结构清晰、可维护的房屋结构。本质上就是调整代码的组织结构，将代码逻辑进行拆分，把复杂的系统拆分成独立的、可复用的组件。</li><li><strong>模块化化</strong>：将代码拆分为不同模块，每个模块负责不同的功能（模块内部可以包含多个组件）。通过这种方式，可以提高代码的可维护性、可复用性、可拓展性。</li><li><strong>工程化</strong>：现在我们已经掌握了如何用积木搭房子，但是在真实的房屋建造过程中，还需要考虑如何进行团队代码管理、版本更新、打包部署、持续集成、流程优化，就是工程化需要学习的内容。</li></ul><h1 id="2-工程化"><a href="#2-工程化" class="headerlink" title="2 工程化"></a>2 工程化</h1><p>截止到这里，我们学习的内容都是基于本地静态项目，如果想要实现最终的目的：在浏览器中输入 url 来访问我们的每日复盘网页，还需要学习更多关于更多工程化的知识。开始之前，让我们思考几个问题：</p><ul><li>如何将本地静态项目变成在互联网上可访问的资源？这之间经历了哪些流程？</li><li>从团队协作的角度来讲，如何才能统一进行代码管理？</li><li>如何实现线上应用的版本管理和更新？</li></ul><p>带着疑问，让我们来看看什么是工程化。</p><h2 id="2-1-前端开发模式进化史"><a href="#2-1-前端开发模式进化史" class="headerlink" title="2.1 前端开发模式进化史"></a>2.1 前端开发模式进化史</h2><p>首先让我们回顾一下前端开发模式的演化历史，前端工程化正是为了应对这些演化中出现的挑战和需求而发展起来的：</p><ul><li>前后端混合：服务端渲染，javascript 仅实现交互</li><li>前后端分离：借助 ajax 实现前后端分离、单页应用(SPA)等新模式</li><li>模块化开发：npm 管理模块、Webpack 编译打包资源</li><li>模块化 + MVVM：基于 React 或 Vue 等框架进行组件化开发，不再手动操作 html 元素</li></ul><h2 id="2-2-工程化含义"><a href="#2-2-工程化含义" class="headerlink" title="2.2 工程化含义"></a>2.2 工程化含义</h2><p>前端工程化是指使用一系列工具、技术和最佳实践来提高前端开发的效率、质量和可维护性的过程。它的核心目标是将前端开发视为一个工程项目，通过规范化、自动化和优化，使得团队能够更好地协作、开发和交付高质量的前端应用。</p><ul><li><strong>模块化开发</strong>：采用模块化开发的方式组织代码，将复杂的前端应用拆分为独立、可重用的模块，提高代码的可读性、可维护性和复用性。</li><li><strong>版本管理和协作</strong>：使用版本管理系统（如 Git）来追踪代码变更和协作开发，确保团队成员之间的代码同步和合并。</li><li><strong>构建</strong>：使用构建工具（如 Webpack、Parcel、Gulp 等）来处理代码的打包、压缩、转换和优化，以生成可部署的静态资源文件。</li><li><strong>自动化测试</strong>：编写和运行自动化测试，包括单元测试、集成测试和端到端测试，以确保代码的质量和功能的稳定性。</li><li><strong>代码规范</strong>：制定代码规范，并使用 Lint 工具（如 ESLint）检查代码是否符合规范，以提高代码质量和一致性。</li><li><strong>自动化部署和持续集成</strong>：通过自动化脚本和持续集成工具（如 Jenkins、Travis CI 等）实现自动化部署和持续集成，简化部署流程和提高交付效率。</li><li><strong>性能优化</strong>：优化前端应用的性能，包括文件大小优化、资源懒加载、缓存策略、代码分割等，以提升用户体验和页面加载速度。</li></ul><blockquote><ul><li><a href="https://juejin.cn/post/7291186181157535800?searchId=2024030116475185EF2DB24AAFBB8440AA">学习前端工程化 1️⃣——前端工程化与模块化</a></li><li><a href="https://juejin.cn/post/6844903588553048077?searchId=2024022920533568EFC91A5BFA5A2B5FBC">前端工程化概述</a></li></ul></blockquote><h1 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3 模块化"></a>3 模块化</h1><h2 id="3-1-什么是前端模块化？"><a href="#3-1-什么是前端模块化？" class="headerlink" title="3.1 什么是前端模块化？"></a>3.1 什么是前端模块化？</h2><ul><li>模块化是指将程序按照功能或逻辑划分为独立的模块，每个模块负责完成特定的功能，模块之间通过接口进行通信和交互。</li><li>模块化的目的是提高代码的可维护性、复用性和可扩展性，使代码结构更清晰、更易于管理。</li><li>模块化通常是在代码层面进行划分，可以采用不同的模块化规范和工具来实现，如 CommonJS、AMD、ES6 模块等。</li></ul><p>为什么要使用模块化？说白了，和组件化类似，但是模块化是从功能层级进行划分的。假设别人的库里有 4 个轮子，但是你只想引用一个 a 轮子，模块化保证了 a 轮子中的变量、命名、函数方法等内容完全独立，在需要的地方引用 a 轮子即可使用。在开发时使用模块化的思路也一样，将一类功能拆分出来，不论从项目管理还是逻辑层级的角度来讲，都非常的清晰。</p><blockquote><p>【拓展】<a href="https://juejin.cn/post/6901178317366362120?searchId=2024022919433687B63DB756ED0C0B2901">理解模块化和总结各种模块化规范使用</a></p></blockquote><h2 id="3-2-模块化规范"><a href="#3-2-模块化规范" class="headerlink" title="3.2 模块化规范"></a>3.2 模块化规范</h2><p>前端模块是一种<strong>规范</strong>，而不是<strong>具体的实现</strong>。比方说 Node.js 实现了 CommonJS 规范，ES6 模块提供了 ESM 规范。这些规范有两个共性：</p><ul><li>将复杂程序根据规范拆分成若干模块，一个模块包括输入和输出</li><li>模块的内部实现是私有的，对外暴露接口与其他模块通信</li></ul><h3 id="🌟CommonJS"><a href="#🌟CommonJS" class="headerlink" title="🌟CommonJS"></a>🌟CommonJS</h3><p>CommonJS 是 Node.js 中默认的模块化规范：</p><p>文件级别的模块作用域(每个文件就是一个作用域)：每个 CommonJS 模块都有自己的作用域。<br>使用 require 函数来导入，通过 module.exports 导出。<br>CommonJS 模块是同步加载的，这意味着模块在导入时会阻塞执行，直到模块完全加载并可用，并且模块加载的顺序会按照其在代码中出现的顺序。<br>模块可以多次加载，首次加载的时候会运行模块并对输出结果进行缓存，再次加载时会直接使用缓存中的结果。</p><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><h3 id="🌟ESM"><a href="#🌟ESM" class="headerlink" title="🌟ESM"></a>🌟ESM</h3><p>前面所说的几种模块化规范都必须在运行时才能确定依赖和输入输出，而 ESModule 的理念是在编译时就确定模块依赖的输入输出。</p><blockquote><p>⭐ CommonJS 和 ESModule 规范对比：</p><ul><li>CommonJS 模块输出的是值的拷贝，ESM 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ESM 模块是编译时输出接口。</li><li>CommonJS 是单个对象导出，多次导出会覆盖之前的结果；ESM 可以导出多个。</li><li>CommonJS 模块是同步加载，ESM 支持异步加载。</li><li>CommonJS 的 this 是当前模块，ESM 的 this 是 undefined。</li></ul></blockquote><p>现在大多数浏览器中默认的模块化规范都是 ESM 了，作为一种规范它已经比较成熟了，但是我们在浏览器模块化问题上仍有一些问题未能解决：</p><p>浏览器没有模块管理能力，模块分散在各个项目中无法复用。<br>性能加载慢，大型项目中无法直接使用。</p><p>为了解决这两个问题，前端工程化又引入了两个新的工具：<br>引入 npm 负责管理模块，引入打包工具比如 webpack 进行打包聚合提高性能。</p><h2 id="3-3-包管理工具"><a href="#3-3-包管理工具" class="headerlink" title="3.3 包管理工具"></a>3.3 包管理工具</h2><h3 id="🌟-npm"><a href="#🌟-npm" class="headerlink" title="🌟 npm"></a>🌟 npm</h3><p>npm（Node Package Manager）是 Node.js 的包管理器，它基于 Node.js 构建，用于安装、管理和发布 JavaScript 包。<br>在 npm 出现之前，开发者想要共享代码和复用代码只能使用复制粘贴的方式，但是当 npm 出现后，开发者可以将所有的模块上传到仓库(registry)中，借助 npm 安装、管理和发布轮子。</p><blockquote><p>【拓展】项目中 npm 包管理工具的应用：package.json&#x2F;yarn.lock 记录了项目依赖的包和其版本信息，并且能够通过 npm&#x2F;yarn 执行代码检查&#x2F;打包构建等自定义脚本；node_modules 文件夹内存储了使用 npm&#x2F;yarn 依赖的第三方包。使用时通过 npm publish 命令发布模块，通过 npm install 命令安装指定模块到 node_modules 目录。</p></blockquote><h3 id="🌟-yarn"><a href="#🌟-yarn" class="headerlink" title="🌟 yarn"></a>🌟 yarn</h3><h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3><p>yarn 和 pnpm 都是 javascript 包管理工具，只不过基于 npm 做了一些改进和变更，并且在应用时有细微的差异，更多内容可以查看官方文档。</p><blockquote><p>【官方文档】</p><ul><li><a href="https://docs.npmjs.com/">npm 官方文档</a></li><li><a href="https://yarn.nodejs.cn/en/docs/install">yarn 官方文档</a></li><li><a href="https://www.pnpm.cn/motivation">pnpm 官方文档</a></li></ul></blockquote><p>【拓展】</p><blockquote><ul><li><strong>什么是 Node.js？</strong><br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，支持在服务器端运行 JavaScript 代码，这使得前端开发人员可以在本地运行 JavaScript 代码，调试和测试前端应用程序。</li><li><strong>什么是运行时环境？</strong><br>运行时环境（Runtime Environment）是指程序在运行时所需的支持环境和资源，用于执行和管理程序代码。运行时环境提供了一系列必要的功能和服务，使得程序能够在特定的平台或环境中正常运行。<br>在软件开发中，不同的编程语言和框架通常需要特定的运行时环境来解释和执行代码。例如，JavaScript 需要浏览器环境或 Node.js 环境来执行，Java 需要 Java 虚拟机（JVM），Python 需要 Python 解释器等。</li></ul></blockquote>  <!-- [带你入坑Nodejs（一）](https://juejin.cn/post/6994255090219483172?searchId=202402281723092EAA9B8D9B37FE6EE9A6)  [带你入坑Nodejs（二）](https://juejin.cn/post/6994980351298764808) --><!-- 运行时环境通常包括以下内容：解释器或编译器：用于将源代码转换为可执行代码的工具，如JavaScript的V8引擎、Java的JVM、Python的解释器等。库和依赖项：程序执行时所需的各种库、框架和依赖项，以支持程序功能的实现。内存管理：用于分配和释放内存资源，确保程序正常运行并避免内存泄漏。输入/输出处理：处理程序与外部环境之间的输入和输出操作，如文件操作、网络通信等。错误处理和异常处理：捕获和处理程序中可能出现的错误和异常，确保程序稳定性和可靠性。 --><h1 id="4-版本管理和协作（Git）"><a href="#4-版本管理和协作（Git）" class="headerlink" title="4. 版本管理和协作（Git）"></a>4. 版本管理和协作（Git）</h1><h2 id="4-1-版本管理工具"><a href="#4-1-版本管理工具" class="headerlink" title="4.1 版本管理工具"></a>4.1 版本管理工具</h2><p>在开发中，版本管理和团队协作尤为重要，借助版本管理工具，能够实现开发变更记录可回溯、同步开发等目标。</p><!-- - 开发变更记录可回溯：通过版本管理工具，可以清晰地记录每次代码变更的内容和历史，使得团队能够轻松地回溯到任何一个特定的开发阶段，查看代码的变化和修复bug的过程。- 协作开发：版本管理工具允许团队成员同时对同一个代码库进行修改，并能够合并彼此的变更，从而实现多人协作开发的目标。- 代码冲突解决：当多名开发者同时修改同一部分代码时，可能会产生冲突。版本管理工具能够帮助团队发现并解决这些冲突，确保代码的一致性和质量。- 稳定发布：通过版本管理工具的分支管理功能，可以实现稳定发布和开发分离，确保稳定版本和开发版本的独立性。 --><p>版本管理工具的发展历史：</p><ul><li><strong>本地版本控制系统</strong>：在本地电脑上采用简单数据库控制版本变更</li><li><strong>集中化的版本控制系统</strong>：比如 SVN，使用单一的集中管理的服务器，存储所有的文件修订版本。但是当中央服务器出现单点故障时，将对所有开发工作造成影响。</li><li><strong>分布式版本控制系统</strong>：比如 Git，Mercurial 以及 Darcs 等，每一个电脑上都存储了整个代码仓库的完备记录，任何一处协同工作的服务器出现故障时，都可以从其他镜像的本地仓库进行复原。</li></ul><h2 id="4-2-Git-基本概念常用命令"><a href="#4-2-Git-基本概念常用命令" class="headerlink" title="4.2 Git 基本概念常用命令"></a>4.2 Git 基本概念常用命令</h2><ul><li><strong>仓库（Repository）</strong>：Git 使用仓库来存储代码和版本历史记录。</li><li><strong>远程仓库（Remote Repository）</strong>：远程仓库是存储在网络上的 Git 仓库，通常用于团队协作。</li><li><strong>本地仓库（Locale Repository）</strong>：本地仓库存储了网络上的 Git 仓库的完整备份，包含了工作区、暂存区和版本历史（Commit History）。开发者可以通过在本地仓库进行提交、分支操作等来管理项目的版本控制，而不需要依赖于网络连接或远程服务器。。</li><li><strong>暂存区（Staging Area）</strong>：暂存区是一个临时存储区域，用于存放将要提交到版本库的修改。</li><li><strong>工作区（Working Directory）</strong>：工作区是指开发者用来修改和编辑文件的本地目录。</li><li><strong>分支（Branch）</strong>：分支是独立于主线开发的代码副本，可以用于实现不同功能的并行开发。</li><li><strong>提交（Commit）</strong>：提交是将代码更改记录到版本历史记录中的操作。</li><li><strong>合并（Merge）</strong>：合并是将不同分支的更改合并到一起的操作。</li></ul><blockquote><ul><li>【拓展知识】SSH（见8.2手动部署——SSH和SFTP协议）</li><li>【拓展知识】<a href="https://juejin.cn/post/7247027696822517819?searchId=20240306105647AB008252513BA7EBF438">如何配置 SSH 管理多个 Git 仓库和以及多个 Github 账号</a>在数字签名中，公钥也用于验证私钥持有者的身份。私钥持有者使用私钥对数据进行签名，然后将签名与数据一起发送给接收方。接收方使用发送方的公钥来验证签名的有效性，以确认发送方的身份和数据的完整性。</li></ul></blockquote><h1 id="5-构建"><a href="#5-构建" class="headerlink" title="5. 构建"></a>5. 构建</h1><h2 id="5-1-为什么需要构建"><a href="#5-1-为什么需要构建" class="headerlink" title="5.1 为什么需要构建"></a>5.1 为什么需要构建</h2><ul><li>浏览器并不能直接解析源代码（比如 less、TypeScript 等），因此需要借助构建工具将源代码转换、优化和打包成浏览器可以解析的静态资源。</li><li>在打包构建的过程中，会对模块重组优化，从而提高性能</li><li>进行依赖管理，以确保项目中所需要的插件和库都能被正确的集成和引用。</li></ul><h2 id="5-2-构建工具"><a href="#5-2-构建工具" class="headerlink" title="5.2 构建工具"></a>5.2 构建工具</h2><table><thead><tr><th>构建工具</th><th>特性</th><th></th></tr></thead><tbody><tr><td>Webpack</td><td>Webpack 是一个强大的模块打包工具，它可以处理各种类型的资源，并提供丰富的插件和配置选项，用于实现代码分割、按需加载、压缩等功能。</td><td></td></tr><tr><td>Parcel</td><td>Parcel 是一个零配置的前端打包工具，它支持多种类型的资源，并具有快速打包的特点，适用于小型项目或快速原型开发。</td><td></td></tr><tr><td>Gulp</td><td>Gulp 是一个基于任务的构建工具，它通过定义任务和处理管道来实现自动化构建。Gulp 可以灵活地处理各种任务，如文件合并、压缩、编译等。</td><td></td></tr><tr><td>Grunt</td><td>是一个基于任务的 JavaScript 工程命令行构建工具。Grunt 生态系统非常庞大，并且一直在增长。由于拥有数量庞大的插件可供选择，因此，你可以利用 Grunt 自动完成任何事，并且花费最少的代价。</td><td></td></tr><tr><td>Vite</td><td>开发模式下借助浏览器对 ESM 的支持，采用 nobundle 的方式进行构建，能提供极致的开发体验；生产模式下则基于 rollup 进行构建。</td><td></td></tr><tr><td>Esbuild</td><td>基于 go 语言实现，代码直接编译成机器码(不用像 js 那样先解析为字节码，再编译为机器码)，构建速度比 webpack 更快。</td><td></td></tr></tbody></table><blockquote><ul><li><a href="https://juejin.cn/post/7250730877372645431?searchId=202403051441292DEE4CB68236E67D8E53#heading-13">浅谈前端工程化</a></li><li><a href="https://juejin.cn/post/7121279495494959111?searchId=202403011101312ADE19147BB02F612558">漫谈构建工具(一): 最近对前端构建工具的一些理解</a></li></ul></blockquote><h2 id="5-3-构建中的操作"><a href="#5-3-构建中的操作" class="headerlink" title="5.3 构建中的操作"></a>5.3 构建中的操作</h2><ul><li>解析 html</li><li>es6 代码转换为 es5</li><li>less &#x2F; sass 代码转换为 css 代码</li><li>代码检查</li><li>代码压缩</li><li>代码混淆</li></ul><p>注：构建后的代码一般放在 dist 文件夹目录下</p><h1 id="6-自动化测试"><a href="#6-自动化测试" class="headerlink" title="6.自动化测试"></a>6.自动化测试</h1><p>TODO：待完善</p><table><thead><tr><th>测试类型</th><th>测试框架</th><th>特性</th></tr></thead><tbody><tr><td>单元测试</td><td></td><td></td></tr><tr><td>集成测试</td><td></td><td></td></tr><tr><td>UI 测试</td><td></td><td></td></tr><tr><td>端到端(e2e)测试</td><td></td><td></td></tr><tr><td>快照测试</td><td></td><td></td></tr></tbody></table><blockquote><p>【待看】<a href="https://juejin.cn/post/7303789262989017099?searchId=20240305195443291C1BC4448458A19511#heading-7">前端自动化 UI 测试的完整方案</a></p></blockquote><h1 id="7-代码规范"><a href="#7-代码规范" class="headerlink" title="7. 代码规范"></a>7. 代码规范</h1><ul><li>在团队开发过程中，需要设定统一的代码规范，保证项目代码风格统一。</li><li>检查基础的语法错误，保证代码质量。</li></ul><p>TODO：待完善</p><table><thead><tr><th>代码风格化工具</th><th>特性</th></tr></thead><tbody><tr><td>ESLint</td><td>代码质量、错误检查</td></tr><tr><td>Prettier</td><td>风格检查</td></tr></tbody></table><blockquote><ul><li>【待看】<a href="https://juejin.cn/post/6936519604697038879">彻底搞懂 ESLint 与 Prettier 之间的爱恨情仇</a></li><li><a href="https://juejin.cn/post/7295805817055166502">Eslint 团队终于妥协了…</a></li></ul></blockquote><h1 id="8-项目部署流程"><a href="#8-项目部署流程" class="headerlink" title="8. 项目部署流程"></a>8. 项目部署流程</h1><h2 id="8-1-什么是部署"><a href="#8-1-什么是部署" class="headerlink" title="8.1 什么是部署"></a>8.1 什么是部署</h2><p>将本地静态资源文件上传至服务器&#x2F;云端存储空间，从而确保从外部可以访问这些文件。</p><p>部署流程总览：<br><img src="/img/blog/route-1.1.png" alt="部署流程" title="部署流程"></p><h2 id="8-2-手动部署"><a href="#8-2-手动部署" class="headerlink" title="8.2 手动部署"></a>8.2 手动部署</h2><p>为将本地文件上传至服务器，通常需使用 SFTP 协议（在 macOS 系统上），通过提供连接信息（包括 IP 地址、用户名、密码等），在本地客户端输入指令以登录到远程服务器。连接成功后，可执行相应操作，进行文件传输或管理。</p><p>只要掌握SFTP的基本语法，就可以实现静态文件上传，即手动部署。但是还可以深入学习以下内容：</p><h3 id="1-SSH-和-SFTP-协议"><a href="#1-SSH-和-SFTP-协议" class="headerlink" title="1.SSH 和 SFTP 协议"></a>1.SSH 和 SFTP 协议</h3><p><strong>SSH（Secure Shell，安全外壳协议）</strong>是一种网络安全传输协议，用于通过加密通信提供安全的远程登录和执行命令的方式。</p><p><strong>SFTP（SSH File Transfer Protocol）</strong>是一种安全文件传输协议，它通过 SSH（Secure Shell）协议进行数据传输，提供了对文件的安全上传、下载和管理。</p><table><thead><tr><th>协议</th><th>macOS 客户端</th><th>windows 客户端</th></tr></thead><tbody><tr><td>SSH</td><td>macOS 终端</td><td>第三方 SSH 客户端软件（如 PuTTY、Git Bash、Windows Terminal 等）</td></tr><tr><td>SFPT</td><td>macOS 终端</td><td>第三方软件（如 FileZilla、WinSCP 等）</td></tr></tbody></table><p>SSH 和 SFTP 的区别：</p><ul><li><p>功能：SSH 用于远程登录和执行命令，提供了对远程服务器的终端访问和管理。它可以在远程服务器上执行命令、编辑文件等操作。而 SFTP 专注于文件传输，提供了对远程文件系统的访问和操作，包括文件上传、下载、目录操作等。</p></li><li><p>加密与安全性：SSH 和 SFTP 都使用加密通信，确保数据在传输过程中的机密性。SSH 通过加密终端会话和命令执行来保护远程登录的安全。而 SFTP 使用 SSH 协议的安全性进行文件传输，保证了文件的安全性和完整性。</p></li><li><p>传输方式：SSH 传输的是命令和输出结果，通过终端会话进行交互。而 SFTP 传输的是文件，可以进行文件的上传、下载和管理。</p></li><li><p>使用场景：SSH 广泛用于远程服务器管理、终端操作和远程命令执行。它适用于需要远程登录和管理服务器的情况。而 SFTP 主要用于文件传输、备份和同步等需求，适用于需要安全传输文件的场景。</p></li></ul><blockquote><ul><li>【拓展学习】命令行解释器（用户和操作系统交互的桥梁），常见的 Unix&#x2F;Linux 系统中的 Shell 包括 Bash（Bourne Again Shell）、Zsh（Z Shell）、Ksh（Korn Shell）、Csh（C Shell）等，每种 Shell 都有其特定的功能和语法。使用 SSH 和远程服务器建立连接后，由目标服务器的 shell 解析具体的操作命令。</li></ul></blockquote><blockquote><ul><li>通过私钥&#x2F;公钥实现连接（在 git 中配置公钥）<a href="https://juejin.cn/post/7205138514869567548?searchId=20240306105647AB008252513BA7EBF438">ssh 远程连接方式总结</a></li></ul></blockquote><h3 id="2-Nginx"><a href="#2-Nginx" class="headerlink" title="2.Nginx"></a>2.Nginx</h3><blockquote><ul><li><a href="https://juejin.cn/post/6844903701459501070?searchId=202403061338529CEF534E000A4BFED3C4">前端必会的 Nginx入门视频教程(共11集)-技术胖</a></li><li><a href="https://juejin.cn/post/7287781316589125687?searchId=202403061338529CEF534E000A4BFED3C4">浅谈前端需要掌握的Nginx知识内容</a></li></ul></blockquote><h2 id="8-3-自动化部署"><a href="#8-3-自动化部署" class="headerlink" title="8.3 自动化部署"></a>8.3 自动化部署</h2><blockquote><ul><li><a href="https://juejin.cn/post/7235091963312717885?searchId=202403052001006FEAE04A59A0E7A0193A">一步步实现Nginx +Docker + Jenkins前端自动化部署</a></li></ul></blockquote><h1 id="9-持续集成与自动化部署"><a href="#9-持续集成与自动化部署" class="headerlink" title="9. 持续集成与自动化部署"></a>9. 持续集成与自动化部署</h1><p>探讨持续集成的概念和重要性<br>介绍如何利用持续集成工具实现自动化测试、构建和部署</p><!--可参考的行文结构：1. 引言在引言部分，介绍前端开发的重要性和前端项目在现代互联网应用中的角色。简要介绍本文将讨论的内容，以及为什么了解前端项目的完整流程对于前端开发者和团队至关重要。2. 前端项目概览这一部分可以介绍前端项目的概念，包括前端项目的组成部分、前端开发的基本工作流程、常用的技术栈和工具等。可以简要介绍前端项目的开发、部署和持续集成等方面。3. 从页面呈现到网页3.1 页面布局与设计介绍页面布局的重要性和基本原则讨论响应式设计和移动优先策略3.2 前端开发流程讨论前端开发的基本流程，包括需求分析、设计、编码、测试等阶段引入前端开发中常用的技术和工具，如 HTML、CSS、JavaScript、前端框架等3.3 页面交互与用户体验探讨页面交互设计和用户体验优化的重要性介绍常见的前端交互设计技巧和最佳实践4. 前端项目的开发4.1 项目架构与组织讨论前端项目的架构设计原则和常见的项目组织结构介绍如何建立可维护、可扩展的前端项目4.2 开发工具与环境探讨前端开发中常用的开发工具和集成环境介绍代码编辑器、版本控制工具、包管理器等工具的使用5. 前端项目的部署与持续集成5.1 项目部署流程介绍前端项目部署的基本流程和方法讨论静态资源的优化和压缩，以提升网页加载性能5.2 持续集成与自动化部署探讨持续集成的概念和重要性介绍如何利用持续集成工具实现自动化测试、构建和部署6. 总结总结全文内容，强调前端项目开发的重要性和复杂性。回顾从页面呈现到网页的完整流程，并鼓励读者进一步深入学习和实践前端项目开发。7. 参考资料列出本文中涉及的相关参考资料、工具和资源，供读者深入学习和了解更多有关前端项目开发的内容。通过以上结构，你可以清晰地呈现前端项目从页面呈现到网页的完整流程，同时帮助读者理解前端开发的基础知识结构和相关技术。希望这个建议对你有所帮助！如果有其他问题，请随时提出。 -->]]></content>
    
    
    <categories>
      
      <category>知识总览</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端知识体系概览（一）——基础入门</title>
    <link href="/2024/02/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2024/02/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>遥想最开始接触前端的时候，是从 html 开始，一步步走到 css， 然后是 javascript，知识学了一箩筐，但是用的时候却完全不会应用，就像是手里拿着积木的小孩，根本不懂要搭出一个怎样的房子。</p><p>后来才意识到，要看清楚道路，才能知道前方的路往哪里走。所以希望能够通过一种通俗易懂的方式，能够讲清楚前端的整体结构，也让我自己对前端相关知识的各部分作用，有深入的认识和了解。</p><span id="more"></span><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-什么是前端？"><a href="#1-什么是前端？" class="headerlink" title="1. 什么是前端？"></a>1. 什么是前端？</h2><p>以你现在看到的博客为例，所有你能看到的内容：页面结构、交互效果、展示内容，都归属于前端的范畴，它包含了 web 网页中所有和用户进行交互的内容。</p><h3 id="前端开发方向"><a href="#前端开发方向" class="headerlink" title="前端开发方向"></a>前端开发方向</h3><p><strong>pc 端</strong></p><ul><li>pc 端前端开发主要针对电脑浏览器的网页应用程序开发，需要考虑的是不同浏览器(Chrome,Firefox,Safari,Edge)之间的兼容性，保证在所有浏览器上都能正常展示和运行。</li><li>pc 端会更注重页面布局宽度、交互方式、功能丰富性等，因为桌面设备有更大的屏幕空间和更强大的性能，可以支持更复杂的页面和交互设计。</li></ul><p><strong>移动端</strong></p><ul><li>移动端前端开发则针对移动设备（手机和平板）的网页应用程序（(h5)开发，由于移动设备的尺寸、分辨率种类繁多，在开发移动端网页时，需要考虑更多响应式、适配性、性能优化，确保网页能够在不同尺寸和方向的移动设备上自适应地展示，并提供流畅的触控交互。</li><li>app 开发：目前已经有混合式或跨平台的开发方式(Reactive Native,Ionic)，使得前端也能够使用熟悉的技术来实现移动应用的开发。</li></ul><h2 id="2-本文概述"><a href="#2-本文概述" class="headerlink" title="2. 本文概述"></a>2. 本文概述</h2><p>在开发过程中，我遇到的最大的两个问题，<span style="background:#BCEE68">第一，不知道学什么，第二，学了不知道在哪里可以用</span>。</p><p>大大小小的知识图谱看了不少，前端学习路径也没少翻，但是还是不能完全回答上面的两个问题。所以，我想从案例出发是最好的，假设我现在想要在 pc 端实现一个记录每日复盘的网站，我需要学习哪些知识才能实现我的目标。</p><p>本文将通过<span style="background:#BCEE68"><strong>知识学习路径</strong></span>和<span style="background:#BCEE68"><strong>项目开发流程</strong></span>相对应的方式，介绍前端开发过程中需要学习的内容，以及这些知识的作用。</p><p>作为前端综述（误），不应该在细节上过多赘述，更多细节还需要在学习过程中加以深入。（搓手手）第一次写这种文章，还有点激动嘞，希望能够不断完善。</p><h1 id="2-前端基础"><a href="#2-前端基础" class="headerlink" title="2. 前端基础"></a>2. 前端基础</h1><p>现在我希望实现一个简单的首页，能够显示网页的标题：<strong>每日复盘</strong>，并能够展示过去一周的复盘记录。</p><p>这需要涉及前端最基础的三个内容：HTML、CSS、JavaScript。<br>其中，HTML 描述了一个页面的内容和框架，CSS 层叠样式表描述了页面展示的样式&#x2F;动画效果，JavaScript 则用于为页面增加交互等行为逻辑。</p><p>打个比方，把网页想象为一个动画人物，那么使用 HTML 实现的就是他的骨架，通过 HTML 的标签语法可以给这个人设置基本的高矮胖瘦；但是如果想要给他穿上好看的衣服、增加一些特效，则需要使用 CSS 实现；通过前两步得到的还只是简单的静态人物，想要实现人物的表情和动作变化，则需要使用 JavaScript 实现。</p><h1 id="3-计算机网络基础"><a href="#3-计算机网络基础" class="headerlink" title="3. 计算机网络基础"></a>3. 计算机网络基础</h1><p>学完 HTML 和 CSS，相信你已经可以制作出一个美观的复盘首页了，你将会面临这样的问题：<br>现在的页面数据都是固定的，如何能够获取到过去一周的复盘记录，并展示到页面上呢？</p><ul><li><strong>《计算机网络》&#x2F;HTTP</strong>：熟悉计算机网络的网络请求方式&#x2F;请求结构等知识点，通过向后端发起网络请求来获取到所需数据；</li><li><strong>《数据结构与算法》</strong>：如果你还需要对获取到的后端数据进行处理，比如进行排序&#x2F;过滤等操作，也许会涉及；</li><li><strong>《网络安全》</strong>：如果你想对你发起的网络请求进行加密，保证你的网站在一个安全的状态运行。</li></ul><p>具体的发起网络请求的实现方式，可以选择使用 JavaScript 的对象 XMLHttpRequest，也可以选择引入第三方 axios 库。这也对应了两种解决问题的思路：<span style="background:#BCEE68">1.自己用原生 js 实现；2.用别人造的轮子(第三方库&#x2F;包&#x2F;框架)。</span></p><p>聪明机智的我们当然要选择用别人的轮子，在 html 文件中引入第三方库：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 直接从网站引入axios库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将axios库下载至本地项目，并通过相对路径引用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/path/to/axios/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就能在 html 文件中使用 axios 库提供的请求方法，结合 javascript 的 DOM 操作方法，在页面上展示历史复盘记录了。</p><h1 id="4-基础知识进阶"><a href="#4-基础知识进阶" class="headerlink" title="4. 基础知识进阶"></a>4. 基础知识进阶</h1><ul><li>CSS预编译（sass、less、Stylus）</li><li>CSS后处理器（PostCss）</li><li>JS超集（TypeScript）</li><li>响应式布局</li><li>兼容性调整</li><li>解决CSS不适用大型项目的三种方案<ul><li>①CSS modules</li><li>②CSS in JS</li><li>③Tailwind CSS</li></ul></li></ul><hr><p><strong>本章知识学习表：</strong></p><table><thead><tr><th>基础知识</th><th>进阶学习</th><th>相关知识</th></tr></thead><tbody><tr><td>HTML</td><td></td><td></td></tr><tr><td>CSS</td><td>SCSS、LESS、PostCss</td><td>响应式布局，兼容性调整</td></tr><tr><td>JavaScript</td><td>TypeScript</td><td>数据结构，计算机网络，操作系统，网络安全</td></tr></tbody></table><p>通过上述知识的学习，可以实现简单页面，但是存在如下问题:</p><!-- - 当前端项目越来越复杂，需要引入的库越来越多时，如何对所有引入的库进行管理和更新，要如何判断引用的依赖关系？ --><p>前端框架很好的解决了这些问题，让我们进入下一个阶段，学习使用框架。</p><h1 id="5-框架"><a href="#5-框架" class="headerlink" title="5. 框架"></a>5. 框架</h1><p>通过学习基础知识，我们已经能够实现单一的前端页面。但是在实际的项目开发中，不仅仅是把若干 html 组合在一起那么简单。考虑如下问题：</p><ul><li>使用原生 javascript 修改页面内容,操作复杂且不灵活</li><li>在一个 html 文件实现一个页面的结构中，如果想在每个页面实现相同的页面结构（比如导航栏），就需要在每个页面中都写一遍，这显然不合理，有没有更好的方法？</li><li>如何能够按照功能模块对项目进行管理？</li></ul><p>并且随着随着页面数量的增加，我们将面临着逻辑复用、项目层级结构管理、第三方库的管理和升级等问题。幸运的是，前端的框架和各类库&#x2F;包已经提供了诸多解决方案，学习如何使用这些框架&#x2F;库，也是前端进阶的一部分。</p><!-- 在此基础上，还需要深入学习<span style="color:#57a7d9">组件化、模块化、工程化</span>的知识，以更好的提高开发效率、降低维护成本。 --><p>目前主流的三类前端框架：React、Vue、Angular。</p><h2 id="5-1-JavaScript框架"><a href="#5-1-JavaScript框架" class="headerlink" title="5.1 JavaScript框架"></a>5.1 JavaScript框架</h2><p>刚开始学习的时候，一定会陷入“我应该先学哪个框架”的困惑中，这里给出三类框架的对比。</p><table><thead><tr><th align="center">框架</th><th>学习曲线</th><th>架构设计</th><th>性能</th><th>生态系统</th></tr></thead><tbody><tr><td align="center">Vue</td><td>被认为是最容易学习和上手的前端框架之一，官方文档简洁易懂，适合初学者。</td><td>Vue 的设计思想是渐进式框架，允许开发者渐进式的使用其特性，易于拓展，适合开发中小型项目。</td><td>性能表现良好，作为轻量级框架，更注重灵活性、简单性和性能</td><td>生态系统较小，但是社区活跃，提供了许多插件和工具。</td></tr><tr><td align="center">React</td><td>学习曲线较为陡峭，需要理解 JSX 和一些基础概念，但是完全掌握后可以很好地进行复杂应用的开发。</td><td>React 是一个库而不是框架，专注于视图层的构建，并鼓励组件化开发和单项数据流，适合构建大型应用和与其他库配合使用。</td><td>React 也具有很好的性能表现，通过虚拟 DOM 实现高效的页面更新，支持服务端渲染。</td><td>React 生态系统庞大，拥有丰富的第三方库和组件，支持 React Native 开发原生应用。</td></tr><tr><td align="center">Angular</td><td>Angular 的学习曲线相对来说更陡峭，它是一个完整的框架，包含了许多概念和机制（如依赖注入、模板语法、指令等），并且需要结合 TypeScript 使用，适合有一定经验的开发者。</td><td>Angular 是一个完整的框架，提供了更多功能和工具（如路由、表单验证、HTTP 模块等），适合企业级应用和团队协作开发。</td><td>Angular 的性能在一定程度上受到影响，因为它是一个完整的框架，可能包含一些额外的开销，但通过优化和懒加载等方式可以改善性能。</td><td>Angular 拥有完整的生态系统，提供了大量的官方库和工具，适合构建复杂的企业级应用。</td></tr></tbody></table><p>虽然几类框架的实现方法不同，但是他们无一例外的都涉及到路由管理、组件传参、状态管理等知识点，为我们提供了很多封装好的功能，所以本质上框架只是工具和路径，掌握最关键的通用逻辑才是最重要的。最好的学习方式就是官方文档加上不断的练习，当你把相关特性和方法都掌握后，面对业务需求的时候就能够做到“心中有技能，拔剑自然神”。</p><blockquote><p>【拓展】关于库和框架的区别<br>框架对项目的结构规范和应用程序的生命周期都进行了限定，使用框架构建应用程序，意味着需要满足这些预定义的结构、规则和约定。而库是一组工具和函数的集合，在项目中可以根据需要引入库中的工具&#x2F;函数而无需受到严格的限制，此外，库主要专注某一特定领域的问题提出解决方案（比如数据处理，网络请求等）</p></blockquote><blockquote><p>【拓展】关于框架的底层架构原理<br>学习过程中你可能会接触到 MVP、MVC 和 MVVM，Vue 采用了 MVVM 架构，Angular 采用了 MVC 架构，而 React 作为 Javascript 库采用了虚拟 DOM 的方式实现了数据驱动视图的效果。<br><a href="https://juejin.cn/post/6844903825225023502?searchId=2024022816050469F71170640EAD6BE7F3">前端面试题：这是我理解的 MVVM，请注意查收</a> &gt; <a href="https://juejin.cn/post/6844903605414133773?searchId=2024022816050469F71170640EAD6BE7F3">MVVM 的实现</a></p></blockquote><h3 id="核心理念与方法"><a href="#核心理念与方法" class="headerlink" title="核心理念与方法"></a>核心理念与方法</h3><p>正如上文所说，虽然框架之间的实现方式和原理存在差异，但是他们有很多理念和方法是相同的，比如：</p><ul><li>组件化</li><li>组件通信</li><li>组件生命周期</li><li>路由管理</li><li>表单处理</li><li>状态管理</li><li>网络请求</li><li>异步数据处理</li><li>持久化存储</li><li>国际化</li><li>主题定制</li></ul><p>除了学习如何使用框架，还需要学习框架的底层原理，达到”知其所以然“的境界。</p><h2 id="5-2-UI-框架"><a href="#5-2-UI-框架" class="headerlink" title="5.2 UI 框架"></a>5.2 UI 框架</h2><p>UI 框架主要面向组件和交互功能，会封装常用的一些组件以供开发者使用，比如按钮、弹窗、表单、表格等，使用 UI 框架可以极大程度的减少 CSS 代码的编辑量，提高开发效率。常见的一些 UI 框架&#x2F;UI 库：</p><table><thead><tr><th>UI 框架&#x2F;UI 库</th><th>支持框架</th><th>支持终端</th></tr></thead><tbody><tr><td>Element-UI，Element-Plus</td><td>Vue</td><td>Web、移动端</td></tr><tr><td>TDesign，AntDesign，Material-UI</td><td>React</td><td>Web、移动端</td></tr><tr><td>NG-ZORRO</td><td>Angular</td><td>Web、移动端</td></tr><tr><td>Ionic</td><td>Angular、React、Vue</td><td>移动端</td></tr><tr><td>Tailwind CSS</td><td>原生 CSS 框架</td><td>不限制</td></tr></tbody></table><h1 id="6-开发理念"><a href="#6-开发理念" class="headerlink" title="6 开发理念"></a>6 开发理念</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul><li>组件化是指将页面或应用拆分为独立的可重用组件，每个组件包含自身的结构、样式和行为，并且可以独立使用或组合成更复杂的界面。</li><li>组件化的目的是提高开发效率、减少重复开发、保持代码一致性，同时促进团队协作和复用。</li><li>组件化通常是在界面层面进行划分，可以采用前端框架（如 Vue、React、Angular）提供的组件化机制来实现</li></ul><p>让我们回顾一下上文提到的问题：</p><blockquote><p>在一个 html 文件实现一个页面的结构中，如果想在每个页面实现相同的页面结构（比如导航栏），就需要在每个页面中都写一遍，这显然不合理，有没有更好的方法？</p></blockquote><p>基于框架实现组件化开发能够完美的解决这个问题。试想假如原来有 10 个页面，每个页面都展示导航栏，如果你想在导航栏中新增一个菜单，就要修改 10 遍导航栏代码！但是按照组件化开发的思路，写一套导航栏组件即可，这样后续有任何变更，也只需要修改一次导航栏组件即可，大大降低了后续维护的成本和难度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习HTML、CSS、JavaScript以及计算机网络的基础知识，结合框架，理论上你已经能够完成一个简单的前端页面了，接下来我们将会介绍如何构建一个完整的前端项目。</p><!-- 但是，如果你打开过框架的官方网站，就一定能看到类似的话：“必须先安装 node.js 和 npm（Node Package Manager）”。相信作为初学者的你和当时的我一样困惑，但没关系，你会在[前端知识体系概览（二）—— 技能进阶]()学到它的基础信息，并在[前端知识体系概览（三）—— 模块化和工程化]()中更深入的了解他们。 -->]]></content>
    
    
    <categories>
      
      <category>知识总览</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>版本控制工具——Git</title>
    <link href="/2024/02/23/git%E5%A4%A7%E6%B3%95%E5%A5%BD..%E9%9A%BE/"/>
    <url>/2024/02/23/git%E5%A4%A7%E6%B3%95%E5%A5%BD..%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<p>使用 Git 已经 7 月有余，虽然不至于再出现合并冲突把别人代码覆盖的的低级错误，但是还是会遇到各种问题，反复学习了若干次 Git，只是熟悉了一些基本的操作，遇到问题时还是解释清楚。但是没关系，查漏补缺，多学几遍总会明白的。</p><span id="more"></span><h1 id="1-发展历史与原理"><a href="#1-发展历史与原理" class="headerlink" title="1. 发展历史与原理"></a>1. 发展历史与原理</h1><h2 id="1-1-版本控制系统发展历史与分类"><a href="#1-1-版本控制系统发展历史与分类" class="headerlink" title="1.1 版本控制系统发展历史与分类"></a>1.1 版本控制系统发展历史与分类</h2><ol><li><strong>本地版本控制系统</strong>：在本地电脑上采用简单数据库控制版本变更。</li><li><strong>集中化的版本控制系统</strong>：使用单一的集中管理的服务器，存储所有的文件修订版本。但是当中央服务器出现单点故障时，将对所有开发工作造成影响。</li><li><strong>分布式版本控制系统</strong>：比如 Git，Mercurial 以及 Darcs 等，每一个电脑上都存储了整个代码仓库的完备记录，任何一处协同工作的服务器出现故障时，都可以从其他镜像的本地仓库进行复原。</li></ol><h2 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h2><p>Git 与其他分支控制系统最大的差异是对待数据的形式，以往的系统（CVS、Subversion、Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 <strong>基于差异（delta-based</strong> 的版本控制）。</p><p>在 Git 中，更像是把数据看作小型文件系统的一系列快照。当文件发生变更时，就会对当前的所有文件创建一个快照，并且记录指向这个快照的索引。为了提高效率，当文件没有发生变更时，git 就不会再保存文件，而是记录一个链接指向之前的存储的文件。</p><ul><li>这个<strong>链接</strong>是什么？</li></ul><p>在 git 保存所有文件变更之前，都会计算<span style="color:green">校验和</span>。在 git 中计算校验和的机制叫做<span style="color:green">SHA-1 散列（hash，哈希）</span>。这是一个由 40 个十六进制自负(0-9 和 a-f)组成的字符串，基于 Git 中文件的内容和目录结构计算出来。SHA-1 哈希看起来是这样：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code><br>在 Git 中，都是用这个校验和（哈希值，上文提到的链接，也称为commitId）作为文件的引用，而不是文件名。</p><h2 id="1-3-Git-分区结构"><a href="#1-3-Git-分区结构" class="headerlink" title="1.3 Git 分区结构"></a>1.3 Git 分区结构</h2><p>Git 分成几个重要的部分，工作区，暂存区，本地仓库，远端仓库。<br><img src="/img/blog/git-1.1.png" alt="git基本操作" title="git基本操作"></p><ol><li><span style="color:orange">本地到远端的操作</span></li><li><span style="color:purple">远端到本地的操作</span></li></ol><h1 id="2-Git-操作"><a href="#2-Git-操作" class="headerlink" title="2. Git 操作"></a>2. Git 操作</h1><!-- ## 2.1 常用操作| 操作   | 作用                                 | 使用范例 || ------ | ------------------------------------ | -------- || add    | 将文件添加到暂存区                   |          || commit | 将暂存区的文件提交到本地仓库         |          || push   | 将本地仓库的文件推送到远端仓库       |          || pull   | 拉取远端仓库的文件内容并更新本地分支 |          || fetch  | 拉取远端仓库的文件                   |          || merge  | 合并远端分支到本地分支               |          || stash  | 将文件添加到暂存区                   |          || revert | 撤销最近一次的 push 记录             |          | --><h2 id="2-1-安装和配置"><a href="#2-1-安装和配置" class="headerlink" title="2.1 安装和配置"></a>2.1 安装和配置</h2><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>init</td><td>将当前的本地项目初始化为Git仓库</td><td><code>git init</code></td></tr><tr><td>clone</td><td>克隆仓库：将远端仓库的所有文件的所有版本都拉取下来</td><td><code>git clone GitUrl</code></td></tr></tbody></table><h2 id="2-2-获取和创建项目"><a href="#2-2-获取和创建项目" class="headerlink" title="2.2 获取和创建项目"></a>2.2 获取和创建项目</h2><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead></table><h2 id="2-3-基础快照"><a href="#2-3-基础快照" class="headerlink" title="2.3 基础快照"></a>2.3 基础快照</h2><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>add</td><td></td><td></td></tr><tr><td>status</td><td></td><td></td></tr><tr><td>diff</td><td></td><td></td></tr><tr><td>commit</td><td></td><td></td></tr><tr><td>notes</td><td></td><td></td></tr><tr><td>restore</td><td></td><td></td></tr><tr><td>reset</td><td></td><td></td></tr><tr><td>rm</td><td></td><td></td></tr><tr><td>mv</td><td></td><td></td></tr></tbody></table><h2 id="2-4-分支和合并"><a href="#2-4-分支和合并" class="headerlink" title="2.4 分支和合并"></a>2.4 分支和合并</h2><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>branch</td><td></td><td></td></tr><tr><td>checkout</td><td></td><td></td></tr><tr><td>switch</td><td></td><td></td></tr><tr><td>merge</td><td></td><td></td></tr><tr><td>mergetool</td><td></td><td></td></tr><tr><td>log</td><td></td><td></td></tr><tr><td>stash</td><td></td><td></td></tr><tr><td>tag</td><td></td><td></td></tr><tr><td>worktree</td><td></td><td></td></tr></tbody></table><h2 id="2-5-分享和更新项目"><a href="#2-5-分享和更新项目" class="headerlink" title="2.5 分享和更新项目"></a>2.5 分享和更新项目</h2><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>fetch</td><td></td><td></td></tr><tr><td>pull</td><td></td><td></td></tr><tr><td>push</td><td></td><td></td></tr><tr><td>remot</td><td></td><td></td></tr><tr><td>submodule</td><td></td><td></td></tr></tbody></table><h2 id="2-6-检查和比较"><a href="#2-6-检查和比较" class="headerlink" title="2.6 检查和比较"></a>2.6 检查和比较</h2><h2 id="2-7-修补"><a href="#2-7-修补" class="headerlink" title="2.7 修补"></a>2.7 修补</h2><h2 id="2-8-调试"><a href="#2-8-调试" class="headerlink" title="2.8 调试"></a>2.8 调试</h2><h2 id="2-9-管理"><a href="#2-9-管理" class="headerlink" title="2.9 管理"></a>2.9 管理</h2><h1 id="3-分支管理"><a href="#3-分支管理" class="headerlink" title="3. 分支管理"></a>3. 分支管理</h1><h2 id="3-1-分支"><a href="#3-1-分支" class="headerlink" title="3.1 分支"></a>3.1 分支</h2><h1 id="4-开发问题"><a href="#4-开发问题" class="headerlink" title="4. 开发问题"></a>4. 开发问题</h1><h2 id="1-代码相同，为什么还是检测出了变更"><a href="#1-代码相同，为什么还是检测出了变更" class="headerlink" title="1. 代码相同，为什么还是检测出了变更"></a>1. 代码相同，为什么还是检测出了变更</h2><p><strong>有远端分支 a 和本地分支 b，通过 git push origin b 将本地分支 b 推送至远端，然后发起合并请求，将远端分支 b 合并进 a，但是在对比变更的时候发现，有些在 a 上的代码和 b 上相同，但是还是提示有变更。</strong></p><p>解析：</p><p>当你将远程分支 B 合并到远程分支 A 时，即使在两个分支上存在相同的代码，也可能会出现提示有变更的情况。这通常是因为 git 在判断是否有变更时，是通过比较提交历史和具体文件内容来确定的。<br>即使两个分支上的某些文件内容相同，在提交历史中它们可能是不同的。这可能是因为这些相同的文件在两个分支上的修改历史并不一样，导致 git 认为它们是不同的版本，从而在合并请求中显示有变更。<br>另外，即使文件内容没有改变，如果文件的元数据（如文件权限或时间戳）发生了变化，git 也会认为这是一个变更。<br>如果你确定两个分支上的代码实际上是相同的，且不希望在合并请求中显示这些“变更”，你可以考虑使用 git rebase 或者 git merge –squash 来合并分支，以减少重复的提交历史记录和变更。这样可以避免在合并请求中出现不必要的变更提示。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://git-scm.com/book/zh/v2">Git 官方文档</a></li><li><a href="https://juejin.cn/post/6844903702374023182">对比 Git 与 SVN，这篇讲的很易懂</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript索引签名</title>
    <link href="/2024/02/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/02/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>已知字符串”str”，尝试通过 obj[‘str’]获取对象 obj 的 str 属性值，但在 typescript 中语法报错。</p><span id="more"></span><h1 id="1-需求描述及实现方式"><a href="#1-需求描述及实现方式" class="headerlink" title="1. 需求描述及实现方式"></a>1. 需求描述及实现方式</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h2><p>在管理端配置自助端的首页功能菜单，在自助端显示配置开关开启的菜单。<br>比如，在管理端设置开启 a&#x2F;b&#x2F;c 功能菜单的开关，则在自助端显示 a&#x2F;b&#x2F;c 功能菜单按键，不显示其他内容。</p><h2 id="2-实际实现方式"><a href="#2-实际实现方式" class="headerlink" title="2.实际实现方式"></a>2.实际实现方式</h2><ol><li>涉及两个接口：setConfig 和 getConfig，分别用于保存配置和获取配置，接口的 data 为属性为布尔值的对象，表示是否显示对应的菜单项。</li><li>管理端：加载页面时，使用 getConfig 的内容更新页面 form 的值，进行数据回显。修改数据进行保存时，使用 setConfig 的 post 方法，修改管理端配置。</li><li>自助端：加载首页时，使用 getConfig 获取配置，并使用 filter 方法过滤菜单数组，仅保留对应 showXXX 属性为 true 的值。</li></ol><p>定义了 SelfConfigFields，规定了接口数据的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelfConfigFields</span> &#123;<br>  <span class="hljs-attr">showApply</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showApplyRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showRegisterRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showOffline</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbindingDevice</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbinding</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了 functionList 用于渲染功能菜单，其中 showKey 的属性值为字符串，指向配置查询接口中对应的属性名称。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">functionList = <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    logUrl<span class="hljs-punctuation">:</span> &#x27;assets/imgs/pc/apply-filing-green.png&#x27;<span class="hljs-punctuation">,</span><br>    name<span class="hljs-punctuation">:</span> &#x27;apply-filing&#x27;<span class="hljs-punctuation">,</span><br>    tip<span class="hljs-punctuation">:</span> &#x27;&#x27;<span class="hljs-punctuation">,</span><br>    index<span class="hljs-punctuation">:</span> &#x27;apply-filing&#x27;<span class="hljs-punctuation">,</span><br>    showKey<span class="hljs-punctuation">:</span> &#x27;showApply&#x27;<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span>;<br></code></pre></td></tr></table></figure><p>在尝试通过 getSelfConfig 方法过滤 show 为 false 的值时</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 获取自助中心配置</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-title function_">getSelfConfig</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">aggregationProtalService</span>.<span class="hljs-title function_">getSelfConfig</span>().<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">functionList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">functionList</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>       <span class="hljs-keyword">return</span> res[item.<span class="hljs-property">showKey</span>]<br>     &#125;)<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><p>在<code>return res[item.showKey]</code>处会出现报错:<br><span style="color:orangered;font-size:14px">元素隐式具有 “any” 类型，因为类型为 “string” 的表达式不能用于索引类型 “SelfConfigFields”。在类型 “SelfConfigFields” 上找不到具有类型为 “string” 的参数的索引签名。</span></p><h1 id="2-知识点解析"><a href="#2-知识点解析" class="headerlink" title="2.知识点解析"></a>2.知识点解析</h1><h2 id="1-读取对象属性"><a href="#1-读取对象属性" class="headerlink" title="1. 读取对象属性"></a>1. 读取对象属性</h2><ol><li>通过点属性读取<br>点属性访问器是在 JavaScript 中访问对象属性的最常见和最直接的方式。它使用点 (.) 表示法来访问对象的特定属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>通过方括号读取<br>直接通过字符串读取</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;name&quot;</span>]);<br></code></pre></td></tr></table></figure><p>通过变量读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[name]);<br></code></pre></td></tr></table></figure><h2 id="2-TypeScript-索引签名"><a href="#2-TypeScript-索引签名" class="headerlink" title="2. TypeScript 索引签名"></a>2. TypeScript 索引签名</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>在 TypeScript 中，索引签名是一种定义对象类型的方式，它允许我们使用<strong>字符串或数字</strong>作为索引来访问对象的属性。</p><p>索引签名最主要的作用就是允许我们动态地添加或访问对象的属性，当我们事先不知道类型属性的所有名称及其值的形状时, 索引签名指定当一个对象被一个字符串索引时，它返回一个指定类型的值。</p><h3 id="2-写法"><a href="#2-写法" class="headerlink" title="2. 写法"></a>2. 写法</h3><ol><li><p>字符串索引签名：<code>[index:string]:type</code></p></li><li><p>数字索引签名:<code>[index:number]:type</code></p></li></ol><p>但是需要保证索引签名的类型和实际属性的类型相匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">//会报错，因为索引签名指定，当通过字符串索引时，对应的类型应该是string，但是name的类型为number</span><br>&#125;<br><span class="hljs-comment">//正确的写法：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">//以下三种写法都可以</span><br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-索引签名的使用"><a href="#3-索引签名的使用" class="headerlink" title="3. 索引签名的使用"></a>3. 索引签名的使用</h3><p>对照上文的需求，应该在 SelfConfigFields 中添加<code>[key: string]: boolean;</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelfConfigFields</span> &#123;<br>  <span class="hljs-attr">showApply</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showApplyRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showRegisterRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showOffline</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbindingDevice</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbinding</span>: <span class="hljs-built_in">boolean</span>;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，通过字符串访问对象的属性时，就不会再报错了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> showName = item.<span class="hljs-property">showKey</span>; <span class="hljs-comment">//&#x27;showApply&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res[showName]); <span class="hljs-comment">//res[&#x27;showApply&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/7223679441901240376">js如何获取对象中的所有属性</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>到底什么是像素值清晰度？</title>
    <link href="/2024/02/10/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%8F%E7%B4%A0%E5%80%BC%E6%B8%85%E6%99%B0%E5%BA%A6%EF%BC%9F/"/>
    <url>/2024/02/10/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%8F%E7%B4%A0%E5%80%BC%E6%B8%85%E6%99%B0%E5%BA%A6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>最近想要生成一个分享海报，需要将背景图和二维码拼接后生成一个新的图片，并通过h5&#x2F;app下载。最初用canvas实现了图片拼接，但是在导出的时候遇到了问题，同样的海报尺寸，为什么h5导出的图片2M,app导出图片的尺寸却有12M？</p><p>为了导出清晰度又高占内存又小的图片，赶紧恶补关于图像的知识，试图弄清楚图片的尺寸、像素值、清晰度和图片容量大小的关系。</p><span id="more"></span><h1 id="遇到的疑问"><a href="#遇到的疑问" class="headerlink" title="遇到的疑问"></a>遇到的疑问</h1><ol><li>为什么在h5和app上绘制的canvas尺寸都是一样的，导出图片的尺寸也一样，大小却是一个2M一个12M？</li><li>为什么1M的图片和12M的图片一样清晰，到底是什么决定了图片的清晰度？</li><li>为什么微信扫码可以识别psd导出的1M海报，却不能识别我通过canvas导出的1M海报，尽管他俩的清晰度看起来完全一样，这两张图片的差别是什么？</li></ol><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><h2 id="1-像素"><a href="#1-像素" class="headerlink" title="1. 像素"></a>1. 像素</h2><p>像素分为逻辑像素（数字像素）和物理像素。</p><ol><li>逻辑像素（Digital Pixel）：逻辑像素是在数字图像中使用的概念，我们经常提到的“像素”就指的是逻辑像素。逻辑像素是图像的基本单位，表示图像最小可见元素。可以将像素理解成一个小方块，一张图片由若干小方块（像素点）组成，每个像素点都有自己的颜色和位置信息。</li><li>物理像素（Physical Pixel）：物理像素是实际显示设备的像素单元。我们可以这么理解，物理像素是硬件开发相关的单位，是基于一个一个的硬件小方块，其大小由硬件厂家设定。</li></ol><h2 id="2-分辨率"><a href="#2-分辨率" class="headerlink" title="2. 分辨率"></a>2. 分辨率</h2><p>和像素一样，分辨率也分为逻辑分辨率和物理分辨率。</p><ol><li>逻辑分辨率通常用于描述图像的像素数量，即水平方向和垂直方向上的像素数量。</li><li>物理分辨率：我们常说的屏幕分辨率指的是物理像素的数量，比如说，分辨率为1920*1080的屏幕，指的是屏幕纵向上有1920像素(px)，横向上有1080像素(px)。</li></ol><h2 id="3-清晰度"><a href="#3-清晰度" class="headerlink" title="3. 清晰度"></a>3. 清晰度</h2><p>为什么相同分辨率的图片，清晰度却不同？</p><p>这是因为像素比只是决定清晰度的一个方面，还有其他原因决定了图片的清晰度：</p><ol><li>压缩方式：比如JPEG图片通常采用有损压缩，可能导致图像细节的丢失，而PNG图片使用无损压缩，能够更好地保留图像细节。</li><li>拍摄设备的质量</li><li>后期处理</li><li>拍摄环境</li></ol><h2 id="4-占用容量大小"><a href="#4-占用容量大小" class="headerlink" title="4. 占用容量大小"></a>4. 占用容量大小</h2><p>文件大小描述了图片文件所占据的存储空间大小，通常来说，图片的占用容量大小描述了以下几个方面：</p><ol><li>文件大小：描述了图片文件在计算机或其他设备中所占据的实际大小。较大的文件大小通常表示图片包含更多的像素和颜色信息，或者使用了较低效率的压缩方法。</li><li>清晰度和细节：通常情况下，占用容量较大的图片具有更多的细节和更高的清晰度，占用容量较小的图片可能会出现失真和模糊，因为他们经过了更多的压缩处理。</li><li>压缩质量：较小的文件大小可能意味着采用了更高效的压缩方法，但有可能导致图片质量下降。</li></ol><h1 id="2-计量单位"><a href="#2-计量单位" class="headerlink" title="2. 计量单位"></a>2. 计量单位</h1><h2 id="1-像素比-DPR"><a href="#1-像素比-DPR" class="headerlink" title="1. 像素比(DPR)"></a>1. 像素比(DPR)</h2><p><strong>像素比 &#x3D; 物理像素&#x2F;逻辑像素</strong></p><p>注：这里的物理像素和逻辑像素，指的是像素的个数，即绘制相同尺寸的图像所需要的物理像素&#x2F;逻辑像素的个数。<br>像素比描述了物理像素和逻辑像素的比值，即<strong>用几个物理像素可以绘制一个逻辑像素</strong>。</p><p>在相同设备上，缩放网页比例，实际就是变更了像素比，当像素比越大时，屏幕能够显示的图片范围就越大。比如有一张分辨率为1234*1234的图片，在1920*1080分辨率的电脑上，就只能显示一小部分。而当我们把图片的像素比（DPR）放大时，图片就会缩小，我们也能看到更多的区域。</p><p>注：在uniapp中可以通过如下方式获取设备的像素比，M10 pro的输出结果为2.7</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> dpr = uni.<span class="hljs-title function_">getSystemInfoSync</span>().<span class="hljs-property">pixelRatio</span>; <span class="hljs-comment">// 获取设备像素比</span><br></code></pre></td></tr></table></figure><h2 id="2-设备分辨率（DPI）"><a href="#2-设备分辨率（DPI）" class="headerlink" title="2. 设备分辨率（DPI）"></a>2. 设备分辨率（DPI）</h2><p>DPI（Dots Per Inch），设备分辨率指的是各类输出设备每英寸上可产生的点数，dpi越大，屏幕显示越细腻。</p><h2 id="3-图像大小的单位"><a href="#3-图像大小的单位" class="headerlink" title="3. 图像大小的单位"></a>3. 图像大小的单位</h2><ul><li><strong>像素（Pixel）</strong>：像素是图像的最小单元，通常用来表示数字图像的分辨率。例如，一个图像的大小可以表示为宽度 x 高度（像素）。例如，2034 x 4393px。</li><li><strong>字节（Byte）</strong>：字节是计算机中存储数据的基本单位，用来表示图像文件的大小。较小的图像通常以字节为单位，例如几百字节或几千字节（KB）。</li><li><strong>千字节（Kilobyte）</strong>：千字节是存储容量的单位，等于1024字节（2^10字节）。较大的图像文件通常以千字节（KB）为单位来表示其大小。</li><li><strong>兆字节（Megabyte）</strong>：兆字节是存储容量的单位，等于1024千字节（2^20字节）。较大的图像文件或高分辨率图像通常以兆字节（MB）为单位来表示其大小。</li><li><strong>吉字节（Gigabyte）</strong>：吉字节是存储容量的单位，等于1024兆字节（2^30字节）。非常大的图像文件或专业图像素材可能以吉字节（GB）为单位来表示其大小。</li></ul><h1 id="问题回顾与解答"><a href="#问题回顾与解答" class="headerlink" title="问题回顾与解答"></a>问题回顾与解答</h1><ol><li><p>为什么在h5和app上绘制的canvas尺寸都是一样的，导出图片的尺寸也一样，大小却是一个2M一个12M？<br>因为在app上导出canvas时，没有做任何图片的压缩处理，导致占用容量过大。</p></li><li><p>为什么1M的图片和12M的图片一样清晰，到底是什么决定了图片的清晰度？<br>和1相同，1M的图片采用了压缩算法，能够很好的缩小图片占用的空间大小。在app导出图片时增加压缩方法，实现了在保证图片质量的情况下缩小图片尺寸。</p></li><li><p>为什么微信扫码可以识别psd导出的1M海报，却不能识别我通过canvas导出的1M海报，尽管他俩的清晰度看起来完全一样，这两张图片的差别是什么？<br>微信扫码识别图片时，可能会收到图片格式、压缩算法、色彩深度等因素的影响。最终的解决办法是增大了二维码区域，这样微信就可以正常识别了。</p></li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://juejin.cn/post/7190723647030427708?searchId=202402102238257CF36A5131E20B589B24">关于物理像素、逻辑像素（css像素）、分辨率、像素比的超详细讲解</a></li><li><a href="https://juejin.cn/post/6918323869824909319?searchId=2024021023301590C1F01125A47F5F2D7C">作为前端，你应该了解的分辨率&#x2F;逻辑像素&#x2F;物理像素&#x2F;retina屏知识🧐</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>UI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 安装和配置</title>
    <link href="/2024/02/07/Hexo%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/07/Hexo%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>一直以来，我都有用博客记录学习的想法，但是未能实现。机缘巧合下，看到了一位大佬用Hexo做的个人博客，终于决定尝试一下。所以就从第一篇Hexo的安装和配置开始吧～</p><span id="more"></span><h1 id="1-运行环境"><a href="#1-运行环境" class="headerlink" title="1.运行环境"></a>1.运行环境</h1><ul><li>打开zsh，下载python: <code>brew install python3</code></li><li>下载node: <code>brew install node</code></li><li>检查python和node是否安装成功: <code>python -v</code> <code>node -v</code></li><li>npm安装hexo: <code>npm install hexo-cli -g</code><br>经过以上几个步骤，hexo所需的运行环境和基础工具包已经具备</li></ul><h1 id="2-Hexo初始配置"><a href="#2-Hexo初始配置" class="headerlink" title="2.Hexo初始配置"></a>2.Hexo初始配置</h1><ul><li>在本地需要放置博客的位置，创建目录:<code>mkdir blog</code></li><li>进入目录: <code>cd blog</code></li><li>将blog初始化为hexo博客文件夹:<code>hexo init</code></li><li>添加通过git上传本地文章的工具包：<code>npm install hexo-deployer-git --save</code></li><li>删除&#x2F;blog&#x2F;source&#x2F;_post&#x2F;目录下的初始化文章:<code>rm source/_post/Hello-world.md</code></li><li>创建自己的第一篇博客，如:<code>hexo n &quot;Hexo 安装和配置&quot;</code></li><li>生成博客的静态文件:<code>hexo generate</code>(可简写为<code>hexo g</code>)</li><li>运行到本地:<code>hexo server</code>(可简写为<code>hexo s</code>)<br>然后打开 <a href="http://localhost:4000/">http://localhost:4000/</a>就可以看到运行在本地的博客</li></ul><h1 id="3-部署配置"><a href="#3-部署配置" class="headerlink" title="3.部署配置"></a>3.部署配置</h1><h2 id="3-1-GitHub-Pages"><a href="#3-1-GitHub-Pages" class="headerlink" title="3.1 GitHub Pages"></a>3.1 GitHub Pages</h2><p>GitHub Pages 是 GitHub 提供的一项静态网站托管服务，可以免费将代码仓库转换成一个完全可访问的静态网站。这对前端工程师来说真是太友好了～</p><ul><li>本地安装git和ssh: <code>brew install git ssh</code></li><li>git配置用户名和邮箱地址: <code>git config --global user.name &quot;your_name&quot; --global user.email &quot;your_email&quot;</code></li><li>ssh生成本地公钥pub_key: <code>ssh-keygen -t rsa -C &quot;your_email&quot;</code></li><li>在本地~&#x2F;.ssh目录下可以看到生成的公钥: <code>cat ~/.ssh/id_rsa.pub</code></li><li>复制公钥，打开自己的github，右上角头像 setting -&gt; 左侧导航栏 SSH and GPG keys -&gt; 中间网页content的右上角 New SSH key -&gt; 填写 Title 并粘贴公钥到 key 中 -&gt; 点击Add SSH key完成配置</li><li>在~&#x2F;.ssh目录下创建config文件: <code>touch ~/.ssh/config</code><br>如果已有config文件，则使用 <code>vim ~/.ssh/config</code></li><li>将以下配置写入config中:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Host</span> <span class="hljs-string">GitHub.com</span><br>    <span class="hljs-string">Hostname</span> <span class="hljs-string">ssh.github.com</span><br>    <span class="hljs-string">Port</span> <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><ul><li>本地机器与github建立连接：<code>ssh -T git@github.com</code> 出现下列信息代表连接github成功：</li></ul><p><code>Hi &#123;YourName&#125;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><ul><li>在Github创建自己的仓库: <code>&#123;username&#125;/&#123;username&#125;.github.io</code> 注意仓库的名称一定是github的username加上.github.io</li><li>在仓库Setting的左侧导航栏找到Pages，自行设置分支（github默认分支名main，可以根据实际情况更改成master）</li><li>在本地blog目录下上传自己的博客到github中: <code>hexo d</code>,等待上传即可<ul><li>注：我在这里遇到了问题，理论上来说建立ssh链接后就无需输入帐密。但是此处需要输入username和password才允许上传，并且这里的password是github的token,可以在<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>中生成</li></ul></li></ul><p>完成上述步骤后，刷新github页面，可以在setting中的GitHub Pages中可看到visit site 按钮，点击跳转可以看到部署在github上的博客<br>借助Github Pages，现在可以通过<code>https://&#123;username&#125;.github.io</code>访问仓库了，可以选择购买域名实现域名自定义</p><h2 id="3-2-Netify部署"><a href="#3-2-Netify部署" class="headerlink" title="3.2 Netify部署"></a>3.2 Netify部署</h2><p>也可以选择现有的网站托管平台，一键部署到网站上并自定义域名。</p><ul><li>以Netify为例，<a href="https://app.netlify.com/start">新建一个网站页面</a>，选择需要关联的 Github&#x2F;BitBucket&#x2F;Gitlab 库，然后遵循网站提示进行配置</li></ul><p>此外，您还可以在项目的README中增加一个 部署至Netlify按钮，这样其他用户在fork或clone了您的项目之后可以方便快捷地一键部署</p><h1 id="5-主题配置"><a href="#5-主题配置" class="headerlink" title="5.主题配置"></a>5.主题配置</h1><p>该博客使用的主题为Fuild</p><ul><li><p>主题地址:<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p></li><li><p>用户手册:<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p></li><li><p>安装fluid主题 <code>npm install --save hexo-theme-fluid</code></p></li><li><p>在blog目录下创建<code>_config.fluid.yml</code>,<code>touch _config.fluid.yml</code>,将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a>内容复制过去。</p></li></ul><h1 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h1><ul><li>每次<code>hexo g</code>之前都<code>hexo clean</code>一下</li><li>使用<code>hexo deploy</code>部署到github上</li><li>hexo文档 <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>更多部署方式详见 <a href="https://hexo.io/zh-cn/docs/one-command-deployment">hexo部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>流程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
