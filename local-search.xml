<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端项目是如何从本地文件展示到网页的？（前端学习路径概览）</title>
    <link href="/2024/02/27/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%88%B0%E7%BD%91%E9%A1%B5%E7%9A%84%EF%BC%9F/"/>
    <url>/2024/02/27/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E5%88%B0%E7%BD%91%E9%A1%B5%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>遥想最开始接触前端的时候，是从html开始，一步步走到css然后是javascript，知识学了一箩筐，但是用的时候却完全不会应用，就像是手里拿着积木的小孩，根本不懂要搭出一个怎样的房子。</p><p>后来才意识到，要看清楚道路，才能知道前方的路往哪里走，才能知道哪些路是必经之路。所以希望能够通过一种通俗易懂的方式，能够讲清楚前端的整体结构，也让我自己对前端相关知识的各部分作用，有一个大致的认识和了解。</p><span id="more"></span><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-什么是前端？"><a href="#1-什么是前端？" class="headerlink" title="1. 什么是前端？"></a>1. 什么是前端？</h2><p>以你现在看到的博客为例，所有你能看的见的内容：页面结构、交互效果、展示内容，都归属于前端的范畴，它包含了web网页中所有和用户进行交互的内容。</p><h3 id="前端开发方向"><a href="#前端开发方向" class="headerlink" title="前端开发方向"></a>前端开发方向</h3><p><strong>pc端</strong></p><ul><li>pc端前端开发主要针对电脑浏览器的网页应用程序开发，需要考虑的是不同浏览器(Chrome,Firefox,Safari,Edge)之间的兼容性，保证在所有浏览器上都能正常展示和运行。</li><li>pc端会更注重页面布局宽度、交互方式、功能丰富性等，因为桌面设备有更大的屏幕空间和更强大的性能，可以支持更复杂的页面和交互设计。</li></ul><p><strong>移动端</strong></p><ul><li>移动端前端开发则针对移动设备（手机和平板）的网页应用程序（(h5)开发，由于移动设备的尺寸、分辨率种类繁多，在开发移动端网页时，需要考虑更多响应式、适配性、性能优化，确保网页能够在不同尺寸和方向的移动设备上自适应地展示，并提供流畅的触控交互。</li><li>app开发：目前已经有混合式或跨平台的开发方式(Reactive Native,Ionic)，使得前端也能够使用熟悉的技术来实现移动应用的开发。</li></ul><h2 id="2-本文概述"><a href="#2-本文概述" class="headerlink" title="2. 本文概述"></a>2. 本文概述</h2><p>在开发过程中，我遇到的最大的两个问题，<span style="background:#87CEFA">第一，不知道学什么，第二，学了不知道在哪里可以用</span>。</p><p>大大小小的知识图谱看了不少，前端学习路径也没少翻，但是还是不能完全回答上面的两个问题。所以，我想从案例出发是最好的，假设我现在想要在pc端实现一个记录每日复盘的网站，我需要学习哪些知识才能实现我的目标。</p><p>本文将通过<span style="background:#87CEFA"><strong>基础知识</strong></span>和<span style="background:#87CEFA"><strong>项目开发</strong></span>相对应的方式，介绍前端开发过程中需要学习的内容，以及这些知识的作用。但是作为一篇科普文（并不），不应该在细节上过多赘述，更多知识还需要在学习过程中加以深入。</p><p>（搓手手）第一次写这种文章，还有点激动嘞，希望能够不断完善。</p><h1 id="2-从单一页面开始"><a href="#2-从单一页面开始" class="headerlink" title="2. 从单一页面开始"></a>2. 从单一页面开始</h1><p>现在我希望实现一个简单的首页，能够显示网页的标题：<strong>每日复盘</strong>，并能够展示过去一周的复盘记录。</p><h2 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1 基础知识"></a>2.1 基础知识</h2><p>这需要涉及前端最基础的三个内容：HTML、CSS、JavaScript。<br>其中，HTML描述了一个页面的内容和框架，CSS层叠样式表描述了页面展示的样式&#x2F;动画效果，JavaScript则用于为页面增加交互等行为逻辑。</p><p>打个比方，把网页想象为一个动画人物，那么使用HTML实现的就是他的骨架，通过HTML的标签语法可以给这个人设置基本的高矮胖瘦；但是如果想要给他穿上好看的衣服、增加一些特效，则需要使用CSS实现；通过前两步得到的还只是简单的静态人物，想要实现人物的表情和动作变化，则需要使用JavaScript实现。</p><h2 id="2-2-发起网络请求及相关理论"><a href="#2-2-发起网络请求及相关理论" class="headerlink" title="2.2 发起网络请求及相关理论"></a>2.2 发起网络请求及相关理论</h2><p>学完HTML和CSS，相信你已经可以制作出一个美观的复盘首页了，你将会面临这样的问题：</p><ul><li>现在的页面数据都是固定的，如何能够获取到过去一周的复盘记录，并展示到页面上呢？</li></ul><p>关于这个问题，需要学习关于<strong>《计算机网络》</strong> ，熟悉计算机网络的网络请求方式&#x2F;请求结构等知识点，通过向后端发起网络请求来获取到所需数据；如果你还需要对获取到的后端数据进行处理，比如进行排序&#x2F;过滤等操作，也许会涉及 <strong>《数据结构》</strong> ;如果你想对你发起的网络请求进行加密，保证你的网站在一个安全的状态运行，也许需要学习 <strong>《网络安全》</strong>。</p><p>具体的发起网络请求的实现方式，可以选择使用JavaScript的对象XMLHttpRequest，也可以选择引入第三方axios库。这也对应了两种解决问题的思路：<span style="background:#87CEFA">1.自己用原生js实现；2.用别人造的轮子(第三方库&#x2F;包&#x2F;框架)。</span></p><p>聪明机智的我们当然要选择用别人的轮子，在html文件中引入第三方库：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 直接从网站引入axios库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将axios库下载至本地项目，并通过相对路径引用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/path/to/axios/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就能在html文件中使用axios库提供的请求方法，结合javascript的DOM操作方法，在页面上展示历史复盘记录了。但是，新的问题又出现了:</p><ul><li>使用原生javascript修改页面内容,操作复杂且不灵活</li><li>在一个html文件实现一个页面的结构中，如果想在每个页面实现相同的页面结构（比如导航栏），就需要在每个页面中都写一遍，这显然不合理，有没有更好的方法？</li><li>如何能够按照功能模块对项目进行管理？</li><li>当前端项目越来越复杂，需要引入的库越来越多时，如何对所有引入的库进行管理和更新，要如何判断引用的依赖关系？</li></ul><p>这些正是前端项目需要考虑的问题，让我们把视野从单一页面拓展到完整的前端项目，正式进入本文要探讨的内容：<strong>前端项目是如何从本地文件展示到网页的？</strong></p><hr><p><strong>本章知识学习表：</strong></p><table><thead><tr><th>基础知识</th><th>进阶学习</th><th>相关理论基础</th></tr></thead><tbody><tr><td>HTML</td><td></td><td></td></tr><tr><td>CSS</td><td>SCSS、LESS</td><td></td></tr><tr><td>JavaScript</td><td>TypeScript</td><td>数据结构，计算机网络，操作系统，网络安全</td></tr></tbody></table><h1 id="3-搭建前端项目"><a href="#3-搭建前端项目" class="headerlink" title="3. 搭建前端项目"></a>3. 搭建前端项目</h1><p>通过学习基础知识，我们已经能够实现单一的前端页面。但是在实际的项目开发中，不仅仅是把若干html组合在一起那么简单，随着页面数量的增加，我们将面临着逻辑复用、项目层级结构管理、第三方库的管理和升级等问题。</p><p>幸运的是，前端的框架和各类库&#x2F;包已经提供了诸多解决方案，学习如何使用这些框架&#x2F;库，也是前端进阶的一部分。在此基础上，还需要深入学习<span style="color:#57a7d9">组件化、模块化、工程化</span>的知识，以更好的提高开发效率、降低维护成本。</p><h2 id="3-1-使用框架之前"><a href="#3-1-使用框架之前" class="headerlink" title="3.1 使用框架之前"></a>3.1 使用框架之前</h2><p>当你尝试使用一个框架搭建前端项目时，官方网站会告诉你，必须先安装node.js和npm（Node Package Manager）。</p><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><ul><li><p><strong>什么是Node.js？</strong></p><blockquote><p>Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，支持在服务器端运行JavaScript代码，这使得前端开发人员可以在本地运行JavaScript代码，调试和测试前端应用程序。</p></blockquote><!-- [带你入坑Nodejs（一）](https://juejin.cn/post/6994255090219483172?searchId=202402281723092EAA9B8D9B37FE6EE9A6)[带你入坑Nodejs（二）](https://juejin.cn/post/6994980351298764808) --><p>  顺便一提，如果想从前端转全栈，nodejs是一个不错的入手点。</p><blockquote><p>什么是运行时环境？<br>运行时环境（Runtime Environment）是指程序在运行时所需的支持环境和资源，用于执行和管理程序代码。运行时环境提供了一系列必要的功能和服务，使得程序能够在特定的平台或环境中正常运行。<br>  在软件开发中，不同的编程语言和框架通常需要特定的运行时环境来解释和执行代码。例如，JavaScript需要浏览器环境或Node.js环境来执行，Java需要Java虚拟机（JVM），Python需要Python解释器等。</p></blockquote></li></ul><!-- 运行时环境通常包括以下内容：解释器或编译器：用于将源代码转换为可执行代码的工具，如JavaScript的V8引擎、Java的JVM、Python的解释器等。库和依赖项：程序执行时所需的各种库、框架和依赖项，以支持程序功能的实现。内存管理：用于分配和释放内存资源，确保程序正常运行并避免内存泄漏。输入/输出处理：处理程序与外部环境之间的输入和输出操作，如文件操作、网络通信等。错误处理和异常处理：捕获和处理程序中可能出现的错误和异常，确保程序稳定性和可靠性。 --><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><ul><li><p>什么是npm？<br>上文提到了轮子，你可以把npm理解为轮子管理器，通过npm，可以安装别人的轮子使用，也可以自己发布轮子到互联网上给别人使用，此外，你也能够很好的管理在项目中你所拥有和需要的轮子。</p><blockquote><p>npm（Node Package Manager）是 Node.js 的包管理器，用于安装、管理和发布 JavaScript 包。<br><a href="https://docs.npmjs.com/">npm官方文档</a></p></blockquote></li><li><p>什么是yarn和pnpm？</p><blockquote><p>他们都是javascript包管理工具，只不过基于npm做了一些改进和变更，并且在应用时有细微的差异，更多内容可以查看官方文档。<br><a href="https://yarn.nodejs.cn/en/docs/install">yarn官方文档</a><br><a href="https://www.pnpm.cn/motivation">pnpm官方文档</a></p></blockquote></li></ul><h2 id="3-2-框架的种类及项目结构"><a href="#3-2-框架的种类及项目结构" class="headerlink" title="3.2 框架的种类及项目结构"></a>3.2 框架的种类及项目结构</h2><p>目前主流的三类前端框架：React、Vue、Angular。<br>虽然几类框架的实现方法不同，但是他们无一例外的都涉及到路由管理、组件传参、状态管理等知识点，为我们提供了很多封装好的功能，所以本质上框架只是工具和实现目标的途径，掌握最关键的通用逻辑才是最重要的。</p><blockquote><p>关于框架的底层架构原理，你可能会接触到MVP、MVC和MVVM，Vue采用了MVVM架构，Angular采用了MVC架构，而React采用了虚拟DOM的方式实现了数据驱动视图的效果。<br><a href="https://juejin.cn/post/6844903825225023502?searchId=2024022816050469F71170640EAD6BE7F3">前端面试题：这是我理解的MVVM，请注意查收</a><br><a href="https://juejin.cn/post/6844903605414133773?searchId=2024022816050469F71170640EAD6BE7F3">MVVM的实现</a><br>TODO:写一篇关于框架底层实现原理的文章</p></blockquote><!-- >在 Angular 中，视图的动态更新是通过数据绑定和变更检测机制来实现的。Angular 提供了一种称为 "脏检查" 的机制，用于检测数据模型的变化并更新视图。具体来说，Angular 实现视图动态更新的主要方式包括以下几个方面：数据绑定：Angular 提供了多种数据绑定方式，包括插值表达式（Interpolation）、属性绑定（Property Binding）、事件绑定（Event Binding）等。通过数据绑定，可以将模型中的数据与视图元素进行关联，当模型数据发生变化时，视图会自动更新以反映最新的数据状态。双向数据绑定：Angular 还提供了双向数据绑定机制，通过 ngModel 指令或 [(ngModel)] 语法，可以实现表单元素与模型数据之间的双向绑定。当用户在表单输入框中输入内容时，模型数据会自动更新，反之亦然。变更检测：Angular 的变更检测机制会监测模型数据的变化，并在必要时更新视图。Angular 使用 Zone.js 来截取异步操作，当数据发生变化时，Angular 将标记组件为 "脏"，并触发变更检测流程，更新相关视图。OnPush 策略：除了默认的变更检测机制外，Angular 还提供了 OnPush 变更检测策略，可以通过 @Component 装饰器的 changeDetection 属性设置为 ChangeDetectionStrategy.OnPush 来启用。使用 OnPush 策略可以提高性能，因为它只会在输入属性发生变化或手动触发变更检测时才执行变更检测。总的来说，Angular 通过数据绑定和变更检测机制实现视图的动态更新，确保视图与模型数据的同步，并提供了灵活的机制来优化性能和响应性。这些机制使开发者能够方便地构建复杂的前端应用，并实现良好的用户体验。 --><h3 id="框架的选择"><a href="#框架的选择" class="headerlink" title="框架的选择"></a>框架的选择</h3><h3 id="前端项目结构"><a href="#前端项目结构" class="headerlink" title="前端项目结构"></a>前端项目结构</h3><ul><li><strong><code>/src</code>：</strong> 存放项目的源代码<ul><li><strong><code>/components</code>：</strong> 存放可复用的组件</li><li><strong><code>/pages</code>：</strong> 存放页面级组件</li><li><strong><code>/assets</code>：</strong> 存放静态资源文件，如图片、字体等</li><li><strong><code>/styles</code>：</strong> 存放样式文件，如 CSS、Sass 等</li><li><strong><code>/utils</code>：</strong> 存放通用工具函数</li></ul></li><li><strong><code>/public</code>：</strong> 存放不需要经过构建处理的静态文件</li><li><strong><code>/build</code>：</strong> 存放构建后的代码</li><li><strong><code>/node_modules</code>：</strong> 存放项目依赖的第三方包</li><li><strong><code>package.json</code>：</strong> 项目的配置文件，包含依赖信息、脚本命令等</li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs axapta">my-vue-test:.<br>│  .browserslistrc<br>│  .env.production<br>│  .eslintrc.js<br>│  .gitignore<br>│  babel.config.js<br>│  package-lock.json<br>│  package.json<br>│  README.md<br>│  vue.config.js<br>│  yarn-error.log<br>│  yarn.lock<br>│<br>├─<span class="hljs-keyword">public</span><br>│      favicon.ico<br>│      <span class="hljs-keyword">index</span>.html<br>│<br>└─src<br>    ├─apis <span class="hljs-comment">//接口文件根据页面或实例模块化</span><br>    │      <span class="hljs-keyword">index</span>.js<br>    │      login.js<br>    │<br>    ├─components <span class="hljs-comment">//工具组件</span><br>    │  └─header<br>    │          <span class="hljs-keyword">index</span>.less<br>    │          <span class="hljs-keyword">index</span>.vue<br>    │<br>    ├─config <span class="hljs-comment">//配置（环境变量配置不同passid等）</span><br>    │      env.js<br>    │      <span class="hljs-keyword">index</span>.js<br>    │<br>    ├─contant <span class="hljs-comment">//常量</span><br>    │      <span class="hljs-keyword">index</span>.js<br>    │<br>    ├─images <span class="hljs-comment">//图片</span><br>    │      logo.png<br>    │<br>    ├─pages <span class="hljs-comment">//多页面vue项目，不同的实例</span><br>    │  ├─<span class="hljs-keyword">index</span> <span class="hljs-comment">//主实例</span><br>    │  │  │  <span class="hljs-keyword">index</span>.js<br>    │  │  │  <span class="hljs-keyword">index</span>.vue<br>    │  │  │  main.js<br>    │  │  │  router.js<br>    │  │  │  store.js<br>    │  │  │<br>    │  │  ├─components <span class="hljs-comment">//业务组件</span><br>    │  │  └─pages <span class="hljs-comment">//此实例中的各个路由</span><br>    │  │      ├─amenu<br>    │  │      │      <span class="hljs-keyword">index</span>.vue<br>    │  │      │<br>    │  │      └─bmenu<br>    │  │              <span class="hljs-keyword">index</span>.vue<br>    │  │<br>    │  └─login <span class="hljs-comment">//另一个实例</span><br>    │          <span class="hljs-keyword">index</span>.js<br>    │          <span class="hljs-keyword">index</span>.vue<br>    │          main.js<br>    │<br>    ├─scripts <span class="hljs-comment">//包含各种常用配置，工具函数</span><br>    │  │  map.js<br>    │  │<br>    │  └─utils<br>    │          helper.js<br>    │<br>    ├─store <span class="hljs-comment">//vuex仓库</span><br>    │  │  <span class="hljs-keyword">index</span>.js<br>    │  │<br>    │  ├─<span class="hljs-keyword">index</span><br>    │  │      actions.js<br>    │  │      getters.js<br>    │  │      <span class="hljs-keyword">index</span>.js<br>    │  │      mutation-types.js<br>    │  │      mutations.js<br>    │  │      state.js<br>    │  │<br>    │  └─user<br>    │          actions.js<br>    │          getters.js<br>    │          <span class="hljs-keyword">index</span>.js<br>    │          mutation-types.js<br>    │          mutations.js<br>    │          state.js<br>    │<br>    └─styles <span class="hljs-comment">//样式统一配置</span><br>        │  components.less<br>        │<br>        ├─animation<br>        │      <span class="hljs-keyword">index</span>.less<br>        │      slide.less<br>        │<br>        ├─base<br>        │      <span class="hljs-keyword">index</span>.less<br>        │      style.less<br>        │      <span class="hljs-built_in">var</span>.less<br>        │      widget.less<br>        │<br>        └─<span class="hljs-keyword">common</span><br>                <span class="hljs-keyword">index</span>.less<br>                reset.less<br>                style.less<br>                transition.less<br><br><br></code></pre></td></tr></table></figure><h1 id="4-前端工程化"><a href="#4-前端工程化" class="headerlink" title="4. 前端工程化"></a>4. 前端工程化</h1><p>在开发过程中我遇到过这些问题：</p><ol><li>相同逻辑写很多遍，修改起来非常困难</li><li></li></ol><p><em><strong>在这里也想提一个我的观点：不考虑html和css，前端所有的代码本质上都是js文件。比如我们后续会提到的组件化、模块化，就是把一套可复用的逻辑装进一个盒子，这个盒子可以是组件，也可以是模块，再通过一些特定的方法，让别人也可以用到这些盒子里的内容。</strong></em></p><h2 id="3-1-版本控制系统Git"><a href="#3-1-版本控制系统Git" class="headerlink" title="3.1 版本控制系统Git"></a>3.1 版本控制系统Git</h2><!-- 可参考的行文结构：1. 引言在引言部分，介绍前端开发的重要性和前端项目在现代互联网应用中的角色。简要介绍本文将讨论的内容，以及为什么了解前端项目的完整流程对于前端开发者和团队至关重要。2. 前端项目概览这一部分可以介绍前端项目的概念，包括前端项目的组成部分、前端开发的基本工作流程、常用的技术栈和工具等。可以简要介绍前端项目的开发、部署和持续集成等方面。3. 从页面呈现到网页3.1 页面布局与设计介绍页面布局的重要性和基本原则讨论响应式设计和移动优先策略3.2 前端开发流程讨论前端开发的基本流程，包括需求分析、设计、编码、测试等阶段引入前端开发中常用的技术和工具，如 HTML、CSS、JavaScript、前端框架等3.3 页面交互与用户体验探讨页面交互设计和用户体验优化的重要性介绍常见的前端交互设计技巧和最佳实践4. 前端项目的开发4.1 项目架构与组织讨论前端项目的架构设计原则和常见的项目组织结构介绍如何建立可维护、可扩展的前端项目4.2 开发工具与环境探讨前端开发中常用的开发工具和集成环境介绍代码编辑器、版本控制工具、包管理器等工具的使用5. 前端项目的部署与持续集成5.1 项目部署流程介绍前端项目部署的基本流程和方法讨论静态资源的优化和压缩，以提升网页加载性能5.2 持续集成与自动化部署探讨持续集成的概念和重要性介绍如何利用持续集成工具实现自动化测试、构建和部署6. 总结总结全文内容，强调前端项目开发的重要性和复杂性。回顾从页面呈现到网页的完整流程，并鼓励读者进一步深入学习和实践前端项目开发。7. 参考资料列出本文中涉及的相关参考资料、工具和资源，供读者深入学习和了解更多有关前端项目开发的内容。通过以上结构，你可以清晰地呈现前端项目从页面呈现到网页的完整流程，同时帮助读者理解前端开发的基础知识结构和相关技术。希望这个建议对你有所帮助！如果有其他问题，请随时提出。 --><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072">廖雪峰-MVVM</a></p>]]></content>
    
    
    <categories>
      
      <category>知识总览</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git大法好...难</title>
    <link href="/2024/02/23/git%E5%A4%A7%E6%B3%95%E5%A5%BD..%E9%9A%BE/"/>
    <url>/2024/02/23/git%E5%A4%A7%E6%B3%95%E5%A5%BD..%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<p>说起来使用 Git 已经 7 月有余，虽然不至于再出现合并冲突把别人代码覆盖的的低级错误，但是还是会遇到各种问题，反复学习了若干次 Git，只是熟悉了一些基本的操作，遇到问题时还是解释清楚。但是没关系，多学几遍总会明白的。</p><span id="more"></span><h1 id="1-发展历史与原理"><a href="#1-发展历史与原理" class="headerlink" title="1. 发展历史与原理"></a>1. 发展历史与原理</h1><h2 id="1-1-版本控制系统发展历史与分类"><a href="#1-1-版本控制系统发展历史与分类" class="headerlink" title="1.1 版本控制系统发展历史与分类"></a>1.1 版本控制系统发展历史与分类</h2><ol><li><strong>本地版本控制系统</strong>（在本地电脑上采用简单数据库控制版本变更）</li><li><strong>集中化的版本控制系统</strong>（使用单一的集中管理的服务器，存储所有的文件修订版本。但是当中央服务器出现单点故障时，将对所有开发工作造成影响。）</li><li><strong>分布式版本控制系统</strong>（比如 Git，Mercurial 以及 Darcs 等，每一个电脑上都存储了整个代码仓库的完备记录，任何一处协同工作的服务器出现故障时，都可以从其他镜像的本地仓库进行复原。</li></ol><h2 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h2><p>Git 与其他分支控制系统最大的差异是对待数据的形式，它直接记录了文件快照，而非记录文件的变更量。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 <strong>基于差异（delta-based</strong> 的版本控制）。</p><p>在 Git 中，更像是把数据看作小型文件系统的一系列快照。当文件发生变更时，就会对当前的所有文件创建一个快照，并且记录指向这个快照的索引。为了提高效率，当文件没有发生变更时，git 就不会再保存文件，而是记录一个链接指向之前的存储的文件。</p><ul><li>这个<strong>链接</strong>是什么？</li></ul><p>在 git 保存所有文件变更之前，都会计算<span style="color:green">校验和</span>。在 git 中计算校验和的机制叫做<span style="color:green">SHA-1 散列（hash，哈希）</span>。这是一个由 40 个十六进制自负(0-9 和 a-f)组成的字符串，基于 Git 中文件的内容和目录结构计算出来。SHA-1 哈希看起来是这样：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code><br>在 Git 中，都是用这个校验和（哈希值，即上文提到的链接）作为文件的引用，而不是文件名。</p><h2 id="1-3-Git-仓库"><a href="#1-3-Git-仓库" class="headerlink" title="1.3 Git 仓库"></a>1.3 Git 仓库</h2><p>Git 分成几个重要的部分，工作区，暂存区，本地仓库，远端仓库。<br><img src="/img/blog/git-1.1.png" alt="git基本操作" title="git基本操作"></p><ol><li><span style="color:orange">本地到远端的操作</span></li><li><span style="color:purple">远端到本地的操作</span></li></ol><h1 id="2-Git-常用操作"><a href="#2-Git-常用操作" class="headerlink" title="2. Git 常用操作"></a>2. Git 常用操作</h1><p><span style="color:orange">最最最最最最常用的操作</span></p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>add</td><td>将文件添加到暂存区</td><td></td></tr><tr><td>commit</td><td>将暂存区的文件提交到本地仓库</td><td></td></tr><tr><td>push</td><td>将本地仓库的文件推送到远端仓库</td><td></td></tr><tr><td>pull</td><td>拉取远端仓库的文件内容并更新本地分支</td><td></td></tr><tr><td>fetch</td><td>拉取远端仓库的文件</td><td></td></tr><tr><td>merge</td><td>合并远端分支到本地分支</td><td></td></tr><tr><td>stash</td><td>将文件添加到暂存区</td><td></td></tr><tr><td>revert</td><td></td><td></td></tr></tbody></table><p>安装和配置</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>init</td><td>初始化仓库</td><td></td></tr><tr><td>clone</td><td>克隆仓库</td><td></td></tr></tbody></table><p>获取和创建项目</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead></table><p>基础快照</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>add</td><td></td><td></td></tr><tr><td>status</td><td></td><td></td></tr><tr><td>diff</td><td></td><td></td></tr><tr><td>commit</td><td></td><td></td></tr><tr><td>notes</td><td></td><td></td></tr><tr><td>restore</td><td></td><td></td></tr><tr><td>reset</td><td></td><td></td></tr><tr><td>rm</td><td></td><td></td></tr><tr><td>mv</td><td></td><td></td></tr></tbody></table><p>分支和合并</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>branch</td><td></td><td></td></tr><tr><td>checkout</td><td></td><td></td></tr><tr><td>switch</td><td></td><td></td></tr><tr><td>merge</td><td></td><td></td></tr><tr><td>mergetool</td><td></td><td></td></tr><tr><td>log</td><td></td><td></td></tr><tr><td>stash</td><td></td><td></td></tr><tr><td>tag</td><td></td><td></td></tr><tr><td>worktree</td><td></td><td></td></tr></tbody></table><p>分享和更新项目</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>fetch</td><td></td><td></td></tr><tr><td>pull</td><td></td><td></td></tr><tr><td>push</td><td></td><td></td></tr><tr><td>remot</td><td></td><td></td></tr><tr><td>submodule</td><td></td><td></td></tr></tbody></table><p>检查和比较</p><p>修补</p><p>调试</p><p>管理</p><h1 id="开发问题"><a href="#开发问题" class="headerlink" title="开发问题"></a>开发问题</h1><h2 id="1-代码相同，为什么还是检测出了变更"><a href="#1-代码相同，为什么还是检测出了变更" class="headerlink" title="1. 代码相同，为什么还是检测出了变更"></a>1. 代码相同，为什么还是检测出了变更</h2><p><strong>有远端分支 a 和本地分支 b，通过 git push origin b 将本地分支 b 推送至远端，然后发起合并请求，将远端分支 b 合并进 a，但是在对比变更的时候发现，有些在 a 上的代码和 b 上相同，但是还是提示有变更。</strong></p><p>解析：</p><p>当你将远程分支 B 合并到远程分支 A 时，即使在两个分支上存在相同的代码，也可能会出现提示有变更的情况。这通常是因为 git 在判断是否有变更时，是通过比较提交历史和具体文件内容来确定的。<br>即使两个分支上的某些文件内容相同，在提交历史中它们可能是不同的。这可能是因为这些相同的文件在两个分支上的修改历史并不一样，导致 git 认为它们是不同的版本，从而在合并请求中显示有变更。<br>另外，即使文件内容没有改变，如果文件的元数据（如文件权限或时间戳）发生了变化，git 也会认为这是一个变更。<br>如果你确定两个分支上的代码实际上是相同的，且不希望在合并请求中显示这些“变更”，你可以考虑使用 git rebase 或者 git merge –squash 来合并分支，以减少重复的提交历史记录和变更。这样可以避免在合并请求中出现不必要的变更提示。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://git-scm.com/book/zh/v2">Git官方文档</a></li><li><a href="https://juejin.cn/post/6844903702374023182">对比 Git 与 SVN，这篇讲的很易懂</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript索引签名</title>
    <link href="/2024/02/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/02/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>已知字符串”str”，尝试通过 obj[‘str’]获取对象 obj 的 str 属性值，但在 typescript 中语法报错。</p><span id="more"></span><h1 id="1-需求描述及实现方式"><a href="#1-需求描述及实现方式" class="headerlink" title="1. 需求描述及实现方式"></a>1. 需求描述及实现方式</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h2><p>在管理端配置自助端的首页功能菜单，在自助端显示配置开关开启的菜单。<br>比如，在管理端设置开启 a&#x2F;b&#x2F;c 功能菜单的开关，则在自助端显示 a&#x2F;b&#x2F;c 功能菜单按键，不显示其他内容。</p><h2 id="2-实际实现方式"><a href="#2-实际实现方式" class="headerlink" title="2.实际实现方式"></a>2.实际实现方式</h2><ol><li>涉及两个接口：setConfig 和 getConfig，分别用于保存配置和获取配置，接口的 data 为属性为布尔值的对象，表示是否显示对应的菜单项。</li><li>管理端：加载页面时，使用 getConfig 的内容更新页面 form 的值，进行数据回显。修改数据进行保存时，使用 setConfig 的 post 方法，修改管理端配置。</li><li>自助端：加载首页时，使用 getConfig 获取配置，并使用 filter 方法过滤菜单数组，仅保留对应 showXXX 属性为 true 的值。</li></ol><p>定义了 SelfConfigFields，规定了接口数据的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelfConfigFields</span> &#123;<br>  <span class="hljs-attr">showApply</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showApplyRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showRegisterRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showOffline</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbindingDevice</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbinding</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了 functionList 用于渲染功能菜单，其中 showKey 的属性值为字符串，指向配置查询接口中对应的属性名称。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">functionList = <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    logUrl<span class="hljs-punctuation">:</span> &#x27;assets/imgs/pc/apply-filing-green.png&#x27;<span class="hljs-punctuation">,</span><br>    name<span class="hljs-punctuation">:</span> &#x27;apply-filing&#x27;<span class="hljs-punctuation">,</span><br>    tip<span class="hljs-punctuation">:</span> &#x27;&#x27;<span class="hljs-punctuation">,</span><br>    index<span class="hljs-punctuation">:</span> &#x27;apply-filing&#x27;<span class="hljs-punctuation">,</span><br>    showKey<span class="hljs-punctuation">:</span> &#x27;showApply&#x27;<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span>;<br></code></pre></td></tr></table></figure><p>在尝试通过 getSelfConfig 方法过滤 show 为 false 的值时</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 获取自助中心配置</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-title function_">getSelfConfig</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">aggregationProtalService</span>.<span class="hljs-title function_">getSelfConfig</span>().<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">functionList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">functionList</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>       <span class="hljs-keyword">return</span> res[item.<span class="hljs-property">showKey</span>]<br>     &#125;)<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><p>在<code>return res[item.showKey]</code>处会出现报错:<br><span style="color:orangered;font-size:14px">元素隐式具有 “any” 类型，因为类型为 “string” 的表达式不能用于索引类型 “SelfConfigFields”。在类型 “SelfConfigFields” 上找不到具有类型为 “string” 的参数的索引签名。</span></p><h1 id="2-知识点解析"><a href="#2-知识点解析" class="headerlink" title="2.知识点解析"></a>2.知识点解析</h1><h2 id="1-读取对象属性"><a href="#1-读取对象属性" class="headerlink" title="1. 读取对象属性"></a>1. 读取对象属性</h2><ol><li>通过点属性读取<br>点属性访问器是在 JavaScript 中访问对象属性的最常见和最直接的方式。它使用点 (.) 表示法来访问对象的特定属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>通过方括号读取<br>直接通过字符串读取</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;name&quot;</span>]);<br></code></pre></td></tr></table></figure><p>通过变量读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[name]);<br></code></pre></td></tr></table></figure><h2 id="2-TypeScript-索引签名"><a href="#2-TypeScript-索引签名" class="headerlink" title="2. TypeScript 索引签名"></a>2. TypeScript 索引签名</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>在 TypeScript 中，索引签名是一种定义对象类型的方式，它允许我们使用<strong>字符串或数字</strong>作为索引来访问对象的属性。</p><p>索引签名最主要的作用就是允许我们动态地添加或访问对象的属性，当我们事先不知道类型属性的所有名称及其值的形状时, 索引签名指定当一个对象被一个字符串索引时，它返回一个指定类型的值。</p><h3 id="2-写法"><a href="#2-写法" class="headerlink" title="2. 写法"></a>2. 写法</h3><ol><li><p>字符串索引签名：<code>[index:string]:type</code></p></li><li><p>数字索引签名:<code>[index:number]:type</code></p></li></ol><p>但是需要保证索引签名的类型和实际属性的类型相匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">//会报错，因为索引签名指定，当通过字符串索引时，对应的类型应该是string，但是name的类型为number</span><br>&#125;<br><span class="hljs-comment">//正确的写法：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">//以下三种写法都可以</span><br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-索引签名的使用"><a href="#3-索引签名的使用" class="headerlink" title="3. 索引签名的使用"></a>3. 索引签名的使用</h3><p>对照上文的需求，应该在 SelfConfigFields 中添加<code>[key: string]: boolean;</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelfConfigFields</span> &#123;<br>  <span class="hljs-attr">showApply</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showApplyRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showRegisterRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showOffline</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbindingDevice</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbinding</span>: <span class="hljs-built_in">boolean</span>;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，通过字符串访问对象的属性时，就不会再报错了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> showName = item.<span class="hljs-property">showKey</span>; <span class="hljs-comment">//&#x27;showApply&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res[showName]); <span class="hljs-comment">//res[&#x27;showApply&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/7223679441901240376">js如何获取对象中的所有属性</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>到底什么是像素值清晰度？</title>
    <link href="/2024/02/10/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%8F%E7%B4%A0%E5%80%BC%E6%B8%85%E6%99%B0%E5%BA%A6%EF%BC%9F/"/>
    <url>/2024/02/10/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%8F%E7%B4%A0%E5%80%BC%E6%B8%85%E6%99%B0%E5%BA%A6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>最近想要生成一个分享海报，需要将背景图和二维码拼接后生成一个新的图片，并通过h5&#x2F;app下载。最初用canvas实现了图片拼接，但是在导出的时候遇到了问题，同样的海报尺寸，为什么h5导出的图片2M,app导出图片的尺寸却有12M？</p><p>为了导出清晰度又高占内存又小的图片，赶紧恶补关于图像的知识，试图弄清楚图片的尺寸、像素值、清晰度和图片容量大小的关系。</p><span id="more"></span><h1 id="遇到的疑问"><a href="#遇到的疑问" class="headerlink" title="遇到的疑问"></a>遇到的疑问</h1><ol><li>为什么在h5和app上绘制的canvas尺寸都是一样的，导出图片的尺寸也一样，大小却是一个2M一个12M？</li><li>为什么1M的图片和12M的图片一样清晰，到底是什么决定了图片的清晰度？</li><li>为什么微信扫码可以识别psd导出的1M海报，却不能识别我通过canvas导出的1M海报，尽管他俩的清晰度看起来完全一样，这两张图片的差别是什么？</li></ol><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><h2 id="1-像素"><a href="#1-像素" class="headerlink" title="1. 像素"></a>1. 像素</h2><p>像素分为逻辑像素（数字像素）和物理像素。</p><ol><li>逻辑像素（Digital Pixel）：逻辑像素是在数字图像中使用的概念，我们经常提到的“像素”就指的是逻辑像素。逻辑像素是图像的基本单位，表示图像最小可见元素。可以将像素理解成一个小方块，一张图片由若干小方块（像素点）组成，每个像素点都有自己的颜色和位置信息。</li><li>物理像素（Physical Pixel）：物理像素是实际显示设备的像素单元。我们可以这么理解，物理像素是硬件开发相关的单位，是基于一个一个的硬件小方块，其大小由硬件厂家设定。</li></ol><h2 id="2-分辨率"><a href="#2-分辨率" class="headerlink" title="2. 分辨率"></a>2. 分辨率</h2><p>和像素一样，分辨率也分为逻辑分辨率和物理分辨率。</p><ol><li>逻辑分辨率通常用于描述图像的像素数量，即水平方向和垂直方向上的像素数量。</li><li>物理分辨率：我们常说的屏幕分辨率指的是物理像素的数量，比如说，分辨率为1920*1080的屏幕，指的是屏幕纵向上有1920像素(px)，横向上有1080像素(px)。</li></ol><h2 id="3-清晰度"><a href="#3-清晰度" class="headerlink" title="3. 清晰度"></a>3. 清晰度</h2><p>为什么相同分辨率的图片，清晰度却不同？</p><p>这是因为像素比只是决定清晰度的一个方面，还有其他原因决定了图片的清晰度：</p><ol><li>压缩方式：比如JPEG图片通常采用有损压缩，可能导致图像细节的丢失，而PNG图片使用无损压缩，能够更好地保留图像细节。</li><li>拍摄设备的质量</li><li>后期处理</li><li>拍摄环境</li></ol><h2 id="4-占用容量大小"><a href="#4-占用容量大小" class="headerlink" title="4. 占用容量大小"></a>4. 占用容量大小</h2><p>文件大小描述了图片文件所占据的存储空间大小，通常来说，图片的占用容量大小描述了以下几个方面：</p><ol><li>文件大小：描述了图片文件在计算机或其他设备中所占据的实际大小。较大的文件大小通常表示图片包含更多的像素和颜色信息，或者使用了较低效率的压缩方法。</li><li>清晰度和细节：通常情况下，占用容量较大的图片具有更多的细节和更高的清晰度，占用容量较小的图片可能会出现失真和模糊，因为他们经过了更多的压缩处理。</li><li>压缩质量：较小的文件大小可能意味着采用了更高效的压缩方法，但有可能导致图片质量下降。</li></ol><h1 id="2-计量单位"><a href="#2-计量单位" class="headerlink" title="2. 计量单位"></a>2. 计量单位</h1><h2 id="1-像素比-DPR"><a href="#1-像素比-DPR" class="headerlink" title="1. 像素比(DPR)"></a>1. 像素比(DPR)</h2><p><strong>像素比 &#x3D; 物理像素&#x2F;逻辑像素</strong></p><p>注：这里的物理像素和逻辑像素，指的是像素的个数，即绘制相同尺寸的图像所需要的物理像素&#x2F;逻辑像素的个数。<br>像素比描述了物理像素和逻辑像素的比值，即<strong>用几个物理像素可以绘制一个逻辑像素</strong>。</p><p>在相同设备上，缩放网页比例，实际就是变更了像素比，当像素比越大时，屏幕能够显示的图片范围就越大。比如有一张分辨率为1234*1234的图片，在1920*1080分辨率的电脑上，就只能显示一小部分。而当我们把图片的像素比（DPR）放大时，图片就会缩小，我们也能看到更多的区域。</p><p>注：在uniapp中可以通过如下方式获取设备的像素比，M10 pro的输出结果为2.7</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> dpr = uni.<span class="hljs-title function_">getSystemInfoSync</span>().<span class="hljs-property">pixelRatio</span>; <span class="hljs-comment">// 获取设备像素比</span><br></code></pre></td></tr></table></figure><h2 id="2-设备分辨率（DPI）"><a href="#2-设备分辨率（DPI）" class="headerlink" title="2. 设备分辨率（DPI）"></a>2. 设备分辨率（DPI）</h2><p>DPI（Dots Per Inch），设备分辨率指的是各类输出设备每英寸上可产生的点数，dpi越大，屏幕显示越细腻。</p><h2 id="3-图像大小的单位"><a href="#3-图像大小的单位" class="headerlink" title="3. 图像大小的单位"></a>3. 图像大小的单位</h2><ul><li><strong>像素（Pixel）</strong>：像素是图像的最小单元，通常用来表示数字图像的分辨率。例如，一个图像的大小可以表示为宽度 x 高度（像素）。例如，2034 x 4393px。</li><li><strong>字节（Byte）</strong>：字节是计算机中存储数据的基本单位，用来表示图像文件的大小。较小的图像通常以字节为单位，例如几百字节或几千字节（KB）。</li><li><strong>千字节（Kilobyte）</strong>：千字节是存储容量的单位，等于1024字节（2^10字节）。较大的图像文件通常以千字节（KB）为单位来表示其大小。</li><li><strong>兆字节（Megabyte）</strong>：兆字节是存储容量的单位，等于1024千字节（2^20字节）。较大的图像文件或高分辨率图像通常以兆字节（MB）为单位来表示其大小。</li><li><strong>吉字节（Gigabyte）</strong>：吉字节是存储容量的单位，等于1024兆字节（2^30字节）。非常大的图像文件或专业图像素材可能以吉字节（GB）为单位来表示其大小。</li></ul><h1 id="问题回顾与解答"><a href="#问题回顾与解答" class="headerlink" title="问题回顾与解答"></a>问题回顾与解答</h1><ol><li><p>为什么在h5和app上绘制的canvas尺寸都是一样的，导出图片的尺寸也一样，大小却是一个2M一个12M？<br>因为在app上导出canvas时，没有做任何图片的压缩处理，导致占用容量过大。</p></li><li><p>为什么1M的图片和12M的图片一样清晰，到底是什么决定了图片的清晰度？<br>和1相同，1M的图片采用了压缩算法，能够很好的缩小图片占用的空间大小。在app导出图片时增加压缩方法，实现了在保证图片质量的情况下缩小图片尺寸。</p></li><li><p>为什么微信扫码可以识别psd导出的1M海报，却不能识别我通过canvas导出的1M海报，尽管他俩的清晰度看起来完全一样，这两张图片的差别是什么？<br>微信扫码识别图片时，可能会收到图片格式、压缩算法、色彩深度等因素的影响。最终的解决办法是增大了二维码区域，这样微信就可以正常识别了。</p></li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://juejin.cn/post/7190723647030427708?searchId=202402102238257CF36A5131E20B589B24">关于物理像素、逻辑像素（css像素）、分辨率、像素比的超详细讲解</a></li><li><a href="https://juejin.cn/post/6918323869824909319?searchId=2024021023301590C1F01125A47F5F2D7C">作为前端，你应该了解的分辨率&#x2F;逻辑像素&#x2F;物理像素&#x2F;retina屏知识🧐</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>页面</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 安装和配置</title>
    <link href="/2024/02/07/Hexo%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/07/Hexo%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>一直以来，我都有用博客记录学习的想法，但是未能实现。机缘巧合下，看到了一位大佬用Hexo做的个人博客，终于决定尝试一下。所以就从第一篇Hexo的安装和配置开始吧～</p><span id="more"></span><h1 id="1-运行环境"><a href="#1-运行环境" class="headerlink" title="1.运行环境"></a>1.运行环境</h1><ul><li>打开zsh，下载python: <code>brew install python3</code></li><li>下载node: <code>brew install node</code></li><li>检查python和node是否安装成功: <code>python -v</code> <code>node -v</code></li><li>npm安装hexo: <code>npm install hexo-cli -g</code><br>经过以上几个步骤，hexo所需的运行环境和基础工具包已经具备</li></ul><h1 id="2-Hexo初始配置"><a href="#2-Hexo初始配置" class="headerlink" title="2.Hexo初始配置"></a>2.Hexo初始配置</h1><ul><li>在本地需要放置博客的位置，创建目录:<code>mkdir blog</code></li><li>进入目录: <code>cd blog</code></li><li>将blog初始化为hexo博客文件夹:<code>hexo init</code></li><li>添加通过git上传本地文章的工具包：<code>npm install hexo-deployer-git --save</code></li><li>删除&#x2F;blog&#x2F;source&#x2F;_post&#x2F;目录下的初始化文章:<code>rm source/_post/Hello-world.md</code></li><li>创建自己的第一篇博客，如:<code>hexo n &quot;Hexo 安装和配置&quot;</code></li><li>生成博客的静态文件:<code>hexo generate</code>(可简写为<code>hexo g</code>)</li><li>运行到本地:<code>hexo server</code>(可简写为<code>hexo s</code>)<br>然后打开 <a href="http://localhost:4000/">http://localhost:4000/</a>就可以看到运行在本地的博客</li></ul><h1 id="3-GitHub-Pages配置"><a href="#3-GitHub-Pages配置" class="headerlink" title="3.GitHub Pages配置"></a>3.GitHub Pages配置</h1><p>GitHub Pages 是 GitHub 提供的一项静态网站托管服务，可以免费将代码仓库转换成一个完全可访问的静态网站。这对前端工程师来说真是太友好了～</p><ul><li>本地安装git和ssh: <code>brew install git ssh</code></li><li>git配置用户名和邮箱地址: <code>git config --global user.name &quot;your_name&quot; --global user.email &quot;your_email&quot;</code></li><li>ssh生成本地公钥pub_key: <code>ssh-keygen -t rsa -C &quot;your_email&quot;</code></li><li>在本地~&#x2F;.ssh目录下可以看到生成的公钥: <code>cat ~/.ssh/id_rsa.pub</code></li><li>复制公钥，打开自己的github，右上角头像 setting -&gt; 左侧导航栏 SSH and GPG keys -&gt; 中间网页content的右上角 New SSH key -&gt; 填写 Title 并粘贴公钥到 key 中 -&gt; 点击Add SSH key完成配置</li><li>在~&#x2F;.ssh目录下创建config文件: <code>touch ~/.ssh/config</code><br>如果已有config文件，则使用 <code>vim ~/.ssh/config</code></li><li>将以下配置写入config中:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Host</span> <span class="hljs-string">GitHub.com</span><br>    <span class="hljs-string">Hostname</span> <span class="hljs-string">ssh.github.com</span><br>    <span class="hljs-string">Port</span> <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><ul><li>本地机器与github建立连接：<code>ssh -T git@github.com</code> 出现下列信息代表连接github成功：</li></ul><p><code>Hi &#123;YourName&#125;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><ul><li>在Github创建自己的仓库: <code>&#123;username&#125;/&#123;username&#125;.github.io</code> 注意仓库的名称一定是github的username加上.github.io</li><li>在仓库Setting的左侧导航栏找到Pages，自行设置分支（github默认分支名main，可以根据实际情况更改成master）</li><li>在本地blog目录下上传自己的博客到github中: <code>hexo d</code>,等待上传即可<ul><li>注：我在这里遇到了问题，理论上来说建立ssh链接后就无需输入帐密。但是此处需要输入username和password才允许上传，并且这里的password是github的token,可以在<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>中生成</li></ul></li></ul><p>完成上述步骤后，刷新github页面，可以在setting中的GitHub Pages中可看到visit site 按钮，点击跳转可以看到部署在github上的博客</p><h1 id="4-主题配置"><a href="#4-主题配置" class="headerlink" title="4.主题配置"></a>4.主题配置</h1><p>该博客使用的主题为Fuild</p><ul><li><p>主题地址:<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p></li><li><p>用户手册:<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p></li><li><p>安装fluid主题 <code>npm install --save hexo-theme-fluid</code></p></li><li><p>在blog目录下创建<code>_config.fluid.yml</code>,<code>touch _config.fluid.yml</code>,将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a>内容复制过去。</p></li></ul><h1 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h1><ul><li>每次<code>hexo g</code>之前都<code>hexo clean</code>一下</li><li>使用<code>hexo deploy</code>部署到github上</li><li>hexo文档 <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>流程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
