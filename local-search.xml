<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端知识体系概览（二）—— 模块化和工程化</title>
    <link href="/2024/03/05/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2024/03/05/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>通过<a href="">前端知识体系概览（一）</a>的学习，也许你已经可以搭建一个比较完整的前端项目，但是对项目结构、模块化、工程化等概念还是不甚清晰，本章将一一讲解。</p><span id="more"></span><h1 id="1-项目结构与目录"><a href="#1-项目结构与目录" class="headerlink" title="1 项目结构与目录"></a>1 项目结构与目录</h1><p>假设现在你已经通过框架创建了一个新的项目，虽然使用不同的框架会导致项目目录的结构和层级有所差异，但他们大体都包含如下内容：</p><ul><li><strong><code>/app</code>：</strong> 存放项目的源代码<ul><li><strong><code>/components</code>：</strong> 存放可复用的组件</li><li><strong><code>/pages</code>：</strong> 存放页面级组件</li><li><strong><code>/assets</code>：</strong> 存放静态资源文件，如图片、字体等</li><li><strong><code>/styles</code>：</strong> 存放样式文件，如 CSS、Sass 等</li><li><strong><code>/utils</code>：</strong> 存放通用工具函数</li></ul></li><li><strong><code>/public</code>或<code>/libs</code>：</strong> 存放公共资源，比如公共组件、全局样式等</li><li><strong><code>/node_modules</code>：</strong> 存放项目依赖的第三方包</li><li><strong><code>/tools</code>：</strong> 存放辅助开发、构建和部署的工具脚本或配置文件</li><li><strong><code>/build</code>或<code>/dist</code>：</strong> 存放构建、打包处理后最终生成的静态文件</li><li><strong><code>/readme.md</code>：</strong> 项目的说明文件</li><li><strong><code>package.json</code>或<code>yarn.lock</code>：</strong> 项目的配置文件，包含依赖信息、脚本命令等</li><li><strong><code>webpack.config.js</code>或<code>babel.config.js</code>:</strong> 构建工具配置文件，用于配置项目的构建流程和打包流程</li></ul><p>从目录看，所涉及的知识点有：</p><ul><li><strong>框架的核心理念和实现方法</strong>：把写代码想像成搭房子，学会框架和基础知识的的使用方法就是拥有了建材和基础的瓦匠工技能。</li><li><strong>组件化、模块化</strong>：学习如何搭建结构清晰、可维护的房屋结构。本质上就是调整代码的组织结构，将代码逻辑进行拆分，把复杂的系统拆分成独立的、可复用的组件。</li><li><strong>模块化化</strong>：将代码拆分为不同模块，每个模块负责不同的功能（模块内部可以包含多个组件）。通过这种方式，可以提高代码的可维护性、可复用性、可拓展性。</li><li><strong>工程化</strong>：现在我们已经掌握了如何用积木搭房子，但是在真实的房屋建造过程中，还需要考虑如何进行团队代码管理、版本更新、打包部署、持续集成、流程优化，就是工程化需要学习的内容。</li></ul><h1 id="2-工程化"><a href="#2-工程化" class="headerlink" title="2 工程化"></a>2 工程化</h1><p>截止到这里，我们学习的内容都是基于本地静态项目，如果想要实现最终的目的：在浏览器中输入 url 来访问我们的每日复盘网页，还需要学习更多关于更多工程化的知识。开始之前，让我们思考几个问题：</p><ul><li>如何将本地静态项目变成在互联网上可访问的资源？这之间经历了哪些流程？</li><li>从团队协作的角度来讲，如何才能统一进行代码管理？</li><li>如何实现线上应用的版本管理和更新？</li></ul><p>带着疑问，让我们来看看什么是工程化。</p><h2 id="2-1-前端开发模式进化史"><a href="#2-1-前端开发模式进化史" class="headerlink" title="2.1 前端开发模式进化史"></a>2.1 前端开发模式进化史</h2><p>首先让我们回顾一下前端开发模式的演化历史，前端工程化正是为了应对这些演化中出现的挑战和需求而发展起来的：</p><ul><li>前后端混合：服务端渲染，javascript 仅实现交互</li><li>前后端分离：借助 ajax 实现前后端分离、单页应用(SPA)等新模式</li><li>模块化开发：npm 管理模块、Webpack 编译打包资源</li><li>模块化 + MVVM：基于 React 或 Vue 等框架进行组件化开发，不再手动操作 html 元素</li></ul><h2 id="2-2-工程化含义"><a href="#2-2-工程化含义" class="headerlink" title="2.2 工程化含义"></a>2.2 工程化含义</h2><p>前端工程化是指使用一系列工具、技术和最佳实践来提高前端开发的效率、质量和可维护性的过程。它的核心目标是将前端开发视为一个工程项目，通过规范化、自动化和优化，使得团队能够更好地协作、开发和交付高质量的前端应用。</p><ul><li><strong>模块化开发</strong>：采用模块化开发的方式组织代码，将复杂的前端应用拆分为独立、可重用的模块，提高代码的可读性、可维护性和复用性。</li><li><strong>版本管理和协作</strong>：使用版本管理系统（如 Git）来追踪代码变更和协作开发，确保团队成员之间的代码同步和合并。</li><li><strong>构建</strong>：使用构建工具（如 Webpack、Parcel、Gulp 等）来处理代码的打包、压缩、转换和优化，以生成可部署的静态资源文件。</li><li><strong>自动化测试</strong>：编写和运行自动化测试，包括单元测试、集成测试和端到端测试，以确保代码的质量和功能的稳定性。</li><li><strong>代码规范</strong>：制定代码规范，并使用 Lint 工具（如 ESLint）检查代码是否符合规范，以提高代码质量和一致性。</li><li><strong>自动化部署和持续集成</strong>：通过自动化脚本和持续集成工具（如 Jenkins、Travis CI 等）实现自动化部署和持续集成，简化部署流程和提高交付效率。</li><li><strong>性能优化</strong>：优化前端应用的性能，包括文件大小优化、资源懒加载、缓存策略、代码分割等，以提升用户体验和页面加载速度。</li></ul><blockquote><ul><li><a href="https://juejin.cn/post/7291186181157535800?searchId=2024030116475185EF2DB24AAFBB8440AA">学习前端工程化 1️⃣——前端工程化与模块化</a></li><li><a href="https://juejin.cn/post/6844903588553048077?searchId=2024022920533568EFC91A5BFA5A2B5FBC">前端工程化概述</a></li></ul></blockquote><h1 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3 模块化"></a>3 模块化</h1><h2 id="3-1-什么是前端模块化？"><a href="#3-1-什么是前端模块化？" class="headerlink" title="3.1 什么是前端模块化？"></a>3.1 什么是前端模块化？</h2><ul><li>模块化是指将程序按照功能或逻辑划分为独立的模块，每个模块负责完成特定的功能，模块之间通过接口进行通信和交互。</li><li>模块化的目的是提高代码的可维护性、复用性和可扩展性，使代码结构更清晰、更易于管理。</li><li>模块化通常是在代码层面进行划分，可以采用不同的模块化规范和工具来实现，如 CommonJS、AMD、ES6 模块等。</li></ul><p>为什么要使用模块化？说白了，和组件化类似，但是模块化是从功能层级进行划分的。假设别人的库里有 4 个轮子，但是你只想引用一个 a 轮子，模块化保证了 a 轮子中的变量、命名、函数方法等内容完全独立，在需要的地方引用 a 轮子即可使用。在开发时使用模块化的思路也一样，将一类功能拆分出来，不论从项目管理还是逻辑层级的角度来讲，都非常的清晰。</p><blockquote><p>【拓展】<a href="https://juejin.cn/post/6901178317366362120?searchId=2024022919433687B63DB756ED0C0B2901">理解模块化和总结各种模块化规范使用</a></p></blockquote><h2 id="3-2-模块化规范"><a href="#3-2-模块化规范" class="headerlink" title="3.2 模块化规范"></a>3.2 模块化规范</h2><p>前端模块是一种<strong>规范</strong>，而不是<strong>具体的实现</strong>。比方说 Node.js 实现了 CommonJS 规范，ES6 模块提供了 ESM 规范。这些规范有两个共性：</p><ul><li>将复杂程序根据规范拆分成若干模块，一个模块包括输入和输出</li><li>模块的内部实现是私有的，对外暴露接口与其他模块通信</li></ul><h3 id="🌟CommonJS"><a href="#🌟CommonJS" class="headerlink" title="🌟CommonJS"></a>🌟CommonJS</h3><p>CommonJS 是 Node.js 中默认的模块化规范：</p><p>文件级别的模块作用域(每个文件就是一个作用域)：每个 CommonJS 模块都有自己的作用域。<br>使用 require 函数来导入，通过 module.exports 导出。<br>CommonJS 模块是同步加载的，这意味着模块在导入时会阻塞执行，直到模块完全加载并可用，并且模块加载的顺序会按照其在代码中出现的顺序。<br>模块可以多次加载，首次加载的时候会运行模块并对输出结果进行缓存，再次加载时会直接使用缓存中的结果。</p><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><h3 id="🌟ESM"><a href="#🌟ESM" class="headerlink" title="🌟ESM"></a>🌟ESM</h3><p>前面所说的几种模块化规范都必须在运行时才能确定依赖和输入输出，而 ESModule 的理念是在编译时就确定模块依赖的输入输出。</p><blockquote><p>⭐ CommonJS 和 ESModule 规范对比：</p><ul><li>CommonJS 模块输出的是值的拷贝，ESM 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ESM 模块是编译时输出接口。</li><li>CommonJS 是单个对象导出，多次导出会覆盖之前的结果；ESM 可以导出多个。</li><li>CommonJS 模块是同步加载，ESM 支持异步加载。</li><li>CommonJS 的 this 是当前模块，ESM 的 this 是 undefined。</li></ul></blockquote><p>现在大多数浏览器中默认的模块化规范都是 ESM 了，作为一种规范它已经比较成熟了，但是我们在浏览器模块化问题上仍有一些问题未能解决：</p><p>浏览器没有模块管理能力，模块分散在各个项目中无法复用。<br>性能加载慢，大型项目中无法直接使用。</p><p>为了解决这两个问题，前端工程化又引入了两个新的工具：<br>引入 npm 负责管理模块，引入打包工具比如 webpack 进行打包聚合提高性能。</p><h2 id="3-3-包管理工具"><a href="#3-3-包管理工具" class="headerlink" title="3.3 包管理工具"></a>3.3 包管理工具</h2><h3 id="🌟-npm"><a href="#🌟-npm" class="headerlink" title="🌟 npm"></a>🌟 npm</h3><p>npm（Node Package Manager）是 Node.js 的包管理器，它基于 Node.js 构建，用于安装、管理和发布 JavaScript 包。<br>在 npm 出现之前，开发者想要共享代码和复用代码只能使用复制粘贴的方式，但是当 npm 出现后，开发者可以将所有的模块上传到仓库(registry)中，借助 npm 安装、管理和发布轮子。</p><blockquote><p>【拓展】项目中 npm 包管理工具的应用：package.json&#x2F;yarn.lock 记录了项目依赖的包和其版本信息，并且能够通过 npm&#x2F;yarn 执行代码检查&#x2F;打包构建等自定义脚本；node_modules 文件夹内存储了使用 npm&#x2F;yarn 依赖的第三方包。使用时通过 npm publish 命令发布模块，通过 npm install 命令安装指定模块到 node_modules 目录。</p></blockquote><h3 id="🌟-yarn"><a href="#🌟-yarn" class="headerlink" title="🌟 yarn"></a>🌟 yarn</h3><h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3><p>yarn 和 pnpm 都是 javascript 包管理工具，只不过基于 npm 做了一些改进和变更，并且在应用时有细微的差异，更多内容可以查看官方文档。</p><blockquote><p>【官方文档】</p><ul><li><a href="https://docs.npmjs.com/">npm 官方文档</a></li><li><a href="https://yarn.nodejs.cn/en/docs/install">yarn 官方文档</a></li><li><a href="https://www.pnpm.cn/motivation">pnpm 官方文档</a></li></ul></blockquote><p>【拓展】</p><blockquote><ul><li><strong>什么是 Node.js？</strong><br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，支持在服务器端运行 JavaScript 代码，这使得前端开发人员可以在本地运行 JavaScript 代码，调试和测试前端应用程序。</li><li><strong>什么是运行时环境？</strong><br>运行时环境（Runtime Environment）是指程序在运行时所需的支持环境和资源，用于执行和管理程序代码。运行时环境提供了一系列必要的功能和服务，使得程序能够在特定的平台或环境中正常运行。<br>在软件开发中，不同的编程语言和框架通常需要特定的运行时环境来解释和执行代码。例如，JavaScript 需要浏览器环境或 Node.js 环境来执行，Java 需要 Java 虚拟机（JVM），Python 需要 Python 解释器等。</li></ul></blockquote>  <!-- [带你入坑Nodejs（一）](https://juejin.cn/post/6994255090219483172?searchId=202402281723092EAA9B8D9B37FE6EE9A6)  [带你入坑Nodejs（二）](https://juejin.cn/post/6994980351298764808) --><!-- 运行时环境通常包括以下内容：解释器或编译器：用于将源代码转换为可执行代码的工具，如JavaScript的V8引擎、Java的JVM、Python的解释器等。库和依赖项：程序执行时所需的各种库、框架和依赖项，以支持程序功能的实现。内存管理：用于分配和释放内存资源，确保程序正常运行并避免内存泄漏。输入/输出处理：处理程序与外部环境之间的输入和输出操作，如文件操作、网络通信等。错误处理和异常处理：捕获和处理程序中可能出现的错误和异常，确保程序稳定性和可靠性。 --><h1 id="4-版本管理和协作（Git）"><a href="#4-版本管理和协作（Git）" class="headerlink" title="4. 版本管理和协作（Git）"></a>4. 版本管理和协作（Git）</h1><h2 id="4-1-版本管理工具"><a href="#4-1-版本管理工具" class="headerlink" title="4.1 版本管理工具"></a>4.1 版本管理工具</h2><p>在开发中，版本管理和团队协作尤为重要，借助版本管理工具，能够实现开发变更记录可回溯、同步开发等目标。</p><!-- - 开发变更记录可回溯：通过版本管理工具，可以清晰地记录每次代码变更的内容和历史，使得团队能够轻松地回溯到任何一个特定的开发阶段，查看代码的变化和修复bug的过程。- 协作开发：版本管理工具允许团队成员同时对同一个代码库进行修改，并能够合并彼此的变更，从而实现多人协作开发的目标。- 代码冲突解决：当多名开发者同时修改同一部分代码时，可能会产生冲突。版本管理工具能够帮助团队发现并解决这些冲突，确保代码的一致性和质量。- 稳定发布：通过版本管理工具的分支管理功能，可以实现稳定发布和开发分离，确保稳定版本和开发版本的独立性。 --><p>版本管理工具的发展历史：</p><ul><li><strong>本地版本控制系统</strong>：在本地电脑上采用简单数据库控制版本变更</li><li><strong>集中化的版本控制系统</strong>：比如 SVN，使用单一的集中管理的服务器，存储所有的文件修订版本。但是当中央服务器出现单点故障时，将对所有开发工作造成影响。</li><li><strong>分布式版本控制系统</strong>：比如 Git，Mercurial 以及 Darcs 等，每一个电脑上都存储了整个代码仓库的完备记录，任何一处协同工作的服务器出现故障时，都可以从其他镜像的本地仓库进行复原。</li></ul><h2 id="4-2-Git-基本概念常用命令"><a href="#4-2-Git-基本概念常用命令" class="headerlink" title="4.2 Git 基本概念常用命令"></a>4.2 Git 基本概念常用命令</h2><ul><li><strong>仓库（Repository）</strong>：Git 使用仓库来存储代码和版本历史记录。</li><li><strong>远程仓库（Remote Repository）</strong>：远程仓库是存储在网络上的 Git 仓库，通常用于团队协作。</li><li><strong>本地仓库（Locale Repository）</strong>：本地仓库存储了网络上的 Git 仓库的完整备份，包含了工作区、暂存区和版本历史（Commit History）。开发者可以通过在本地仓库进行提交、分支操作等来管理项目的版本控制，而不需要依赖于网络连接或远程服务器。。</li><li><strong>暂存区（Staging Area）</strong>：暂存区是一个临时存储区域，用于存放将要提交到版本库的修改。</li><li><strong>工作区（Working Directory）</strong>：工作区是指开发者用来修改和编辑文件的本地目录。</li><li><strong>分支（Branch）</strong>：分支是独立于主线开发的代码副本，可以用于实现不同功能的并行开发。</li><li><strong>提交（Commit）</strong>：提交是将代码更改记录到版本历史记录中的操作。</li><li><strong>合并（Merge）</strong>：合并是将不同分支的更改合并到一起的操作。</li></ul><blockquote><ul><li>【拓展知识】SSH（见8.2手动部署——SSH和SFTP协议）</li><li>【拓展知识】<a href="https://juejin.cn/post/7247027696822517819?searchId=20240306105647AB008252513BA7EBF438">如何配置 SSH 管理多个 Git 仓库和以及多个 Github 账号</a>在数字签名中，公钥也用于验证私钥持有者的身份。私钥持有者使用私钥对数据进行签名，然后将签名与数据一起发送给接收方。接收方使用发送方的公钥来验证签名的有效性，以确认发送方的身份和数据的完整性。</li></ul></blockquote><h1 id="5-构建"><a href="#5-构建" class="headerlink" title="5. 构建"></a>5. 构建</h1><h2 id="5-1-为什么需要构建"><a href="#5-1-为什么需要构建" class="headerlink" title="5.1 为什么需要构建"></a>5.1 为什么需要构建</h2><ul><li>浏览器并不能直接解析源代码（比如 less、TypeScript 等），因此需要借助构建工具将源代码转换、优化和打包成浏览器可以解析的静态资源。</li><li>在打包构建的过程中，会对模块重组优化，从而提高性能</li><li>进行依赖管理，以确保项目中所需要的插件和库都能被正确的集成和引用。</li></ul><h2 id="5-2-构建工具"><a href="#5-2-构建工具" class="headerlink" title="5.2 构建工具"></a>5.2 构建工具</h2><table><thead><tr><th>构建工具</th><th>特性</th><th></th></tr></thead><tbody><tr><td>Webpack</td><td>Webpack 是一个强大的模块打包工具，它可以处理各种类型的资源，并提供丰富的插件和配置选项，用于实现代码分割、按需加载、压缩等功能。</td><td></td></tr><tr><td>Parcel</td><td>Parcel 是一个零配置的前端打包工具，它支持多种类型的资源，并具有快速打包的特点，适用于小型项目或快速原型开发。</td><td></td></tr><tr><td>Gulp</td><td>Gulp 是一个基于任务的构建工具，它通过定义任务和处理管道来实现自动化构建。Gulp 可以灵活地处理各种任务，如文件合并、压缩、编译等。</td><td></td></tr><tr><td>Grunt</td><td>是一个基于任务的 JavaScript 工程命令行构建工具。Grunt 生态系统非常庞大，并且一直在增长。由于拥有数量庞大的插件可供选择，因此，你可以利用 Grunt 自动完成任何事，并且花费最少的代价。</td><td></td></tr><tr><td>Vite</td><td>开发模式下借助浏览器对 ESM 的支持，采用 nobundle 的方式进行构建，能提供极致的开发体验；生产模式下则基于 rollup 进行构建。</td><td></td></tr><tr><td>Esbuild</td><td>基于 go 语言实现，代码直接编译成机器码(不用像 js 那样先解析为字节码，再编译为机器码)，构建速度比 webpack 更快。</td><td></td></tr></tbody></table><blockquote><ul><li><a href="https://juejin.cn/post/7250730877372645431?searchId=202403051441292DEE4CB68236E67D8E53#heading-13">浅谈前端工程化</a></li><li><a href="https://juejin.cn/post/7121279495494959111?searchId=202403011101312ADE19147BB02F612558">漫谈构建工具(一): 最近对前端构建工具的一些理解</a></li></ul></blockquote><h2 id="5-3-构建中的操作"><a href="#5-3-构建中的操作" class="headerlink" title="5.3 构建中的操作"></a>5.3 构建中的操作</h2><ul><li>解析 html</li><li>es6 代码转换为 es5</li><li>less &#x2F; sass 代码转换为 css 代码</li><li>代码检查</li><li>代码压缩</li><li>代码混淆</li></ul><p>注：构建后的代码一般放在 dist 文件夹目录下</p><h1 id="6-自动化测试"><a href="#6-自动化测试" class="headerlink" title="6.自动化测试"></a>6.自动化测试</h1><p>TODO：待完善</p><table><thead><tr><th>测试类型</th><th>测试框架</th><th>特性</th></tr></thead><tbody><tr><td>单元测试</td><td></td><td></td></tr><tr><td>集成测试</td><td></td><td></td></tr><tr><td>UI 测试</td><td></td><td></td></tr><tr><td>端到端(e2e)测试</td><td></td><td></td></tr><tr><td>快照测试</td><td></td><td></td></tr></tbody></table><blockquote><p>【待看】<a href="https://juejin.cn/post/7303789262989017099?searchId=20240305195443291C1BC4448458A19511#heading-7">前端自动化 UI 测试的完整方案</a></p></blockquote><h1 id="7-代码规范"><a href="#7-代码规范" class="headerlink" title="7. 代码规范"></a>7. 代码规范</h1><ul><li>在团队开发过程中，需要设定统一的代码规范，保证项目代码风格统一。</li><li>检查基础的语法错误，保证代码质量。</li></ul><p>TODO：待完善</p><table><thead><tr><th>代码风格化工具</th><th>特性</th></tr></thead><tbody><tr><td>ESLint</td><td>代码质量、错误检查</td></tr><tr><td>Prettier</td><td>风格检查</td></tr></tbody></table><blockquote><ul><li>【待看】<a href="https://juejin.cn/post/6936519604697038879">彻底搞懂 ESLint 与 Prettier 之间的爱恨情仇</a></li><li><a href="https://juejin.cn/post/7295805817055166502">Eslint 团队终于妥协了…</a></li></ul></blockquote><h1 id="8-项目部署流程"><a href="#8-项目部署流程" class="headerlink" title="8. 项目部署流程"></a>8. 项目部署流程</h1><h2 id="8-1-什么是部署"><a href="#8-1-什么是部署" class="headerlink" title="8.1 什么是部署"></a>8.1 什么是部署</h2><p>将本地静态资源文件上传至服务器&#x2F;云端存储空间，从而确保从外部可以访问这些文件。</p><p>部署流程总览：<br><img src="/img/blog/route-1.1.png" alt="部署流程" title="部署流程"></p><h2 id="8-2-手动部署"><a href="#8-2-手动部署" class="headerlink" title="8.2 手动部署"></a>8.2 手动部署</h2><p>为将本地文件上传至服务器，通常需使用 SFTP 协议（在 macOS 系统上），通过提供连接信息（包括 IP 地址、用户名、密码等），在本地客户端输入指令以登录到远程服务器。连接成功后，可执行相应操作，进行文件传输或管理。</p><p>只要掌握SFTP的基本语法，就可以实现静态文件上传，即手动部署。但是还可以深入学习以下内容：</p><h3 id="1-SSH-和-SFTP-协议"><a href="#1-SSH-和-SFTP-协议" class="headerlink" title="1.SSH 和 SFTP 协议"></a>1.SSH 和 SFTP 协议</h3><p><strong>SSH（Secure Shell，安全外壳协议）</strong>是一种网络安全传输协议，用于通过加密通信提供安全的远程登录和执行命令的方式。</p><p><strong>SFTP（SSH File Transfer Protocol）</strong>是一种安全文件传输协议，它通过 SSH（Secure Shell）协议进行数据传输，提供了对文件的安全上传、下载和管理。</p><table><thead><tr><th>协议</th><th>macOS 客户端</th><th>windows 客户端</th></tr></thead><tbody><tr><td>SSH</td><td>macOS 终端</td><td>第三方 SSH 客户端软件（如 PuTTY、Git Bash、Windows Terminal 等）</td></tr><tr><td>SFPT</td><td>macOS 终端</td><td>第三方软件（如 FileZilla、WinSCP 等）</td></tr></tbody></table><p>SSH 和 SFTP 的区别：</p><ul><li><p>功能：SSH 用于远程登录和执行命令，提供了对远程服务器的终端访问和管理。它可以在远程服务器上执行命令、编辑文件等操作。而 SFTP 专注于文件传输，提供了对远程文件系统的访问和操作，包括文件上传、下载、目录操作等。</p></li><li><p>加密与安全性：SSH 和 SFTP 都使用加密通信，确保数据在传输过程中的机密性。SSH 通过加密终端会话和命令执行来保护远程登录的安全。而 SFTP 使用 SSH 协议的安全性进行文件传输，保证了文件的安全性和完整性。</p></li><li><p>传输方式：SSH 传输的是命令和输出结果，通过终端会话进行交互。而 SFTP 传输的是文件，可以进行文件的上传、下载和管理。</p></li><li><p>使用场景：SSH 广泛用于远程服务器管理、终端操作和远程命令执行。它适用于需要远程登录和管理服务器的情况。而 SFTP 主要用于文件传输、备份和同步等需求，适用于需要安全传输文件的场景。</p></li></ul><blockquote><ul><li>【拓展学习】命令行解释器（用户和操作系统交互的桥梁），常见的 Unix&#x2F;Linux 系统中的 Shell 包括 Bash（Bourne Again Shell）、Zsh（Z Shell）、Ksh（Korn Shell）、Csh（C Shell）等，每种 Shell 都有其特定的功能和语法。使用 SSH 和远程服务器建立连接后，由目标服务器的 shell 解析具体的操作命令。</li></ul></blockquote><blockquote><ul><li>通过私钥&#x2F;公钥实现连接（在 git 中配置公钥）<a href="https://juejin.cn/post/7205138514869567548?searchId=20240306105647AB008252513BA7EBF438">ssh 远程连接方式总结</a></li></ul></blockquote><h3 id="2-Nginx"><a href="#2-Nginx" class="headerlink" title="2.Nginx"></a>2.Nginx</h3><blockquote><ul><li><a href="https://juejin.cn/post/6844903701459501070?searchId=202403061338529CEF534E000A4BFED3C4">前端必会的 Nginx入门视频教程(共11集)-技术胖</a></li><li><a href="https://juejin.cn/post/7287781316589125687?searchId=202403061338529CEF534E000A4BFED3C4">浅谈前端需要掌握的Nginx知识内容</a></li></ul></blockquote><h2 id="8-3-自动化部署"><a href="#8-3-自动化部署" class="headerlink" title="8.3 自动化部署"></a>8.3 自动化部署</h2><blockquote><ul><li><a href="https://juejin.cn/post/7235091963312717885?searchId=202403052001006FEAE04A59A0E7A0193A">一步步实现Nginx +Docker + Jenkins前端自动化部署</a></li></ul></blockquote><h1 id="9-持续集成与自动化部署"><a href="#9-持续集成与自动化部署" class="headerlink" title="9. 持续集成与自动化部署"></a>9. 持续集成与自动化部署</h1><p>探讨持续集成的概念和重要性<br>介绍如何利用持续集成工具实现自动化测试、构建和部署</p><!--可参考的行文结构：1. 引言在引言部分，介绍前端开发的重要性和前端项目在现代互联网应用中的角色。简要介绍本文将讨论的内容，以及为什么了解前端项目的完整流程对于前端开发者和团队至关重要。2. 前端项目概览这一部分可以介绍前端项目的概念，包括前端项目的组成部分、前端开发的基本工作流程、常用的技术栈和工具等。可以简要介绍前端项目的开发、部署和持续集成等方面。3. 从页面呈现到网页3.1 页面布局与设计介绍页面布局的重要性和基本原则讨论响应式设计和移动优先策略3.2 前端开发流程讨论前端开发的基本流程，包括需求分析、设计、编码、测试等阶段引入前端开发中常用的技术和工具，如 HTML、CSS、JavaScript、前端框架等3.3 页面交互与用户体验探讨页面交互设计和用户体验优化的重要性介绍常见的前端交互设计技巧和最佳实践4. 前端项目的开发4.1 项目架构与组织讨论前端项目的架构设计原则和常见的项目组织结构介绍如何建立可维护、可扩展的前端项目4.2 开发工具与环境探讨前端开发中常用的开发工具和集成环境介绍代码编辑器、版本控制工具、包管理器等工具的使用5. 前端项目的部署与持续集成5.1 项目部署流程介绍前端项目部署的基本流程和方法讨论静态资源的优化和压缩，以提升网页加载性能5.2 持续集成与自动化部署探讨持续集成的概念和重要性介绍如何利用持续集成工具实现自动化测试、构建和部署6. 总结总结全文内容，强调前端项目开发的重要性和复杂性。回顾从页面呈现到网页的完整流程，并鼓励读者进一步深入学习和实践前端项目开发。7. 参考资料列出本文中涉及的相关参考资料、工具和资源，供读者深入学习和了解更多有关前端项目开发的内容。通过以上结构，你可以清晰地呈现前端项目从页面呈现到网页的完整流程，同时帮助读者理解前端开发的基础知识结构和相关技术。希望这个建议对你有所帮助！如果有其他问题，请随时提出。 -->]]></content>
    
    
    <categories>
      
      <category>知识总览</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端知识体系概览（一）——基础入门</title>
    <link href="/2024/02/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2024/02/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>遥想最开始接触前端的时候，是从 html 开始，一步步走到 css， 然后是 javascript，知识学了一箩筐，但是用的时候却完全不会应用，就像是手里拿着积木的小孩，根本不懂要搭出一个怎样的房子。</p><p>后来才意识到，要看清楚道路，才能知道前方的路往哪里走。所以希望能够通过一种通俗易懂的方式，能够讲清楚前端的整体结构，也让我自己对前端相关知识的各部分作用，有深入的认识和了解。</p><span id="more"></span><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><h2 id="1-什么是前端？"><a href="#1-什么是前端？" class="headerlink" title="1. 什么是前端？"></a>1. 什么是前端？</h2><p>以你现在看到的博客为例，所有你能看到的内容：页面结构、交互效果、展示内容，都归属于前端的范畴，它包含了 web 网页中所有和用户进行交互的内容。</p><h3 id="前端开发方向"><a href="#前端开发方向" class="headerlink" title="前端开发方向"></a>前端开发方向</h3><p><strong>pc 端</strong></p><ul><li>pc 端前端开发主要针对电脑浏览器的网页应用程序开发，需要考虑的是不同浏览器(Chrome,Firefox,Safari,Edge)之间的兼容性，保证在所有浏览器上都能正常展示和运行。</li><li>pc 端会更注重页面布局宽度、交互方式、功能丰富性等，因为桌面设备有更大的屏幕空间和更强大的性能，可以支持更复杂的页面和交互设计。</li></ul><p><strong>移动端</strong></p><ul><li>移动端前端开发则针对移动设备（手机和平板）的网页应用程序（(h5)开发，由于移动设备的尺寸、分辨率种类繁多，在开发移动端网页时，需要考虑更多响应式、适配性、性能优化，确保网页能够在不同尺寸和方向的移动设备上自适应地展示，并提供流畅的触控交互。</li><li>app 开发：目前已经有混合式或跨平台的开发方式(Reactive Native,Ionic)，使得前端也能够使用熟悉的技术来实现移动应用的开发。</li></ul><h2 id="2-本文概述"><a href="#2-本文概述" class="headerlink" title="2. 本文概述"></a>2. 本文概述</h2><p>在开发过程中，我遇到的最大的两个问题，<span style="background:#87CEFA">第一，不知道学什么，第二，学了不知道在哪里可以用</span>。</p><p>大大小小的知识图谱看了不少，前端学习路径也没少翻，但是还是不能完全回答上面的两个问题。所以，我想从案例出发是最好的，假设我现在想要在 pc 端实现一个记录每日复盘的网站，我需要学习哪些知识才能实现我的目标。</p><p>本文将通过<span style="background:#87CEFA"><strong>知识学习路径</strong></span>和<span style="background:#87CEFA"><strong>项目开发流程</strong></span>相对应的方式，介绍前端开发过程中需要学习的内容，以及这些知识的作用。</p><p>作为前端综述（误），不应该在细节上过多赘述，更多细节还需要在学习过程中加以深入。（搓手手）第一次写这种文章，还有点激动嘞，希望能够不断完善。</p><h1 id="2-前端基础"><a href="#2-前端基础" class="headerlink" title="2. 前端基础"></a>2. 前端基础</h1><p>现在我希望实现一个简单的首页，能够显示网页的标题：<strong>每日复盘</strong>，并能够展示过去一周的复盘记录。</p><p>这需要涉及前端最基础的三个内容：HTML、CSS、JavaScript。<br>其中，HTML 描述了一个页面的内容和框架，CSS 层叠样式表描述了页面展示的样式&#x2F;动画效果，JavaScript 则用于为页面增加交互等行为逻辑。</p><p>打个比方，把网页想象为一个动画人物，那么使用 HTML 实现的就是他的骨架，通过 HTML 的标签语法可以给这个人设置基本的高矮胖瘦；但是如果想要给他穿上好看的衣服、增加一些特效，则需要使用 CSS 实现；通过前两步得到的还只是简单的静态人物，想要实现人物的表情和动作变化，则需要使用 JavaScript 实现。</p><h1 id="3-计算机网络基础"><a href="#3-计算机网络基础" class="headerlink" title="3. 计算机网络基础"></a>3. 计算机网络基础</h1><p>学完 HTML 和 CSS，相信你已经可以制作出一个美观的复盘首页了，你将会面临这样的问题：<br>现在的页面数据都是固定的，如何能够获取到过去一周的复盘记录，并展示到页面上呢？</p><ul><li><strong>《计算机网络》&#x2F;HTTP</strong>：熟悉计算机网络的网络请求方式&#x2F;请求结构等知识点，通过向后端发起网络请求来获取到所需数据；</li><li><strong>《数据结构与算法》</strong>：如果你还需要对获取到的后端数据进行处理，比如进行排序&#x2F;过滤等操作，也许会涉及；</li><li><strong>《网络安全》</strong>：如果你想对你发起的网络请求进行加密，保证你的网站在一个安全的状态运行。</li></ul><p>具体的发起网络请求的实现方式，可以选择使用 JavaScript 的对象 XMLHttpRequest，也可以选择引入第三方 axios 库。这也对应了两种解决问题的思路：<span style="background:#87CEFA">1.自己用原生 js 实现；2.用别人造的轮子(第三方库&#x2F;包&#x2F;框架)。</span></p><p>聪明机智的我们当然要选择用别人的轮子，在 html 文件中引入第三方库：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 直接从网站引入axios库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将axios库下载至本地项目，并通过相对路径引用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/path/to/axios/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就能在 html 文件中使用 axios 库提供的请求方法，结合 javascript 的 DOM 操作方法，在页面上展示历史复盘记录了。</p><h1 id="4-基础知识进阶"><a href="#4-基础知识进阶" class="headerlink" title="4. 基础知识进阶"></a>4. 基础知识进阶</h1><ul><li>CSS预编译（sass、less、Stylus）</li><li>CSS后处理器（PostCss）</li><li>JS超集（TypeScript）</li><li>响应式布局</li><li>兼容性调整</li><li>解决CSS不适用大型项目的三种方案<ul><li>①CSS modules</li><li>②CSS in JS</li><li>③Tailwind CSS</li></ul></li></ul><hr><p><strong>本章知识学习表：</strong></p><table><thead><tr><th>基础知识</th><th>进阶学习</th><th>相关知识</th></tr></thead><tbody><tr><td>HTML</td><td></td><td></td></tr><tr><td>CSS</td><td>SCSS、LESS、PostCss</td><td>响应式布局，兼容性调整</td></tr><tr><td>JavaScript</td><td>TypeScript</td><td>数据结构，计算机网络，操作系统，网络安全</td></tr></tbody></table><p>通过上述知识的学习，可以实现简单页面，但是存在如下问题:</p><!-- - 当前端项目越来越复杂，需要引入的库越来越多时，如何对所有引入的库进行管理和更新，要如何判断引用的依赖关系？ --><p>前端框架很好的解决了这些问题，让我们进入下一个阶段，学习使用框架。</p><h1 id="5-框架"><a href="#5-框架" class="headerlink" title="5. 框架"></a>5. 框架</h1><p>通过学习基础知识，我们已经能够实现单一的前端页面。但是在实际的项目开发中，不仅仅是把若干 html 组合在一起那么简单。考虑如下问题：</p><ul><li>使用原生 javascript 修改页面内容,操作复杂且不灵活</li><li>在一个 html 文件实现一个页面的结构中，如果想在每个页面实现相同的页面结构（比如导航栏），就需要在每个页面中都写一遍，这显然不合理，有没有更好的方法？</li><li>如何能够按照功能模块对项目进行管理？</li></ul><p>并且随着随着页面数量的增加，我们将面临着逻辑复用、项目层级结构管理、第三方库的管理和升级等问题。幸运的是，前端的框架和各类库&#x2F;包已经提供了诸多解决方案，学习如何使用这些框架&#x2F;库，也是前端进阶的一部分。</p><!-- 在此基础上，还需要深入学习<span style="color:#57a7d9">组件化、模块化、工程化</span>的知识，以更好的提高开发效率、降低维护成本。 --><p>目前主流的三类前端框架：React、Vue、Angular。</p><h2 id="5-1-JavaScript框架"><a href="#5-1-JavaScript框架" class="headerlink" title="5.1 JavaScript框架"></a>5.1 JavaScript框架</h2><p>刚开始学习的时候，一定会陷入“我应该先学哪个框架”的困惑中，这里给出三类框架的对比。</p><table><thead><tr><th align="center">框架</th><th>学习曲线</th><th>架构设计</th><th>性能</th><th>生态系统</th></tr></thead><tbody><tr><td align="center">Vue</td><td>被认为是最容易学习和上手的前端框架之一，官方文档简洁易懂，适合初学者。</td><td>Vue 的设计思想是渐进式框架，允许开发者渐进式的使用其特性，易于拓展，适合开发中小型项目。</td><td>性能表现良好，作为轻量级框架，更注重灵活性、简单性和性能</td><td>生态系统较小，但是社区活跃，提供了许多插件和工具。</td></tr><tr><td align="center">React</td><td>学习曲线较为陡峭，需要理解 JSX 和一些基础概念，但是完全掌握后可以很好地进行复杂应用的开发。</td><td>React 是一个库而不是框架，专注于视图层的构建，并鼓励组件化开发和单项数据流，适合构建大型应用和与其他库配合使用。</td><td>React 也具有很好的性能表现，通过虚拟 DOM 实现高效的页面更新，支持服务端渲染。</td><td>React 生态系统庞大，拥有丰富的第三方库和组件，支持 React Native 开发原生应用。</td></tr><tr><td align="center">Angular</td><td>Angular 的学习曲线相对来说更陡峭，它是一个完整的框架，包含了许多概念和机制（如依赖注入、模板语法、指令等），并且需要结合 TypeScript 使用，适合有一定经验的开发者。</td><td>Angular 是一个完整的框架，提供了更多功能和工具（如路由、表单验证、HTTP 模块等），适合企业级应用和团队协作开发。</td><td>Angular 的性能在一定程度上受到影响，因为它是一个完整的框架，可能包含一些额外的开销，但通过优化和懒加载等方式可以改善性能。</td><td>Angular 拥有完整的生态系统，提供了大量的官方库和工具，适合构建复杂的企业级应用。</td></tr></tbody></table><p>虽然几类框架的实现方法不同，但是他们无一例外的都涉及到路由管理、组件传参、状态管理等知识点，为我们提供了很多封装好的功能，所以本质上框架只是工具和路径，掌握最关键的通用逻辑才是最重要的。最好的学习方式就是官方文档加上不断的练习，当你把相关特性和方法都掌握后，面对业务需求的时候就能够做到“心中有技能，拔剑自然神”。</p><blockquote><p>【拓展】关于库和框架的区别<br>框架对项目的结构规范和应用程序的生命周期都进行了限定，使用框架构建应用程序，意味着需要满足这些预定义的结构、规则和约定。而库是一组工具和函数的集合，在项目中可以根据需要引入库中的工具&#x2F;函数而无需受到严格的限制，此外，库主要专注某一特定领域的问题提出解决方案（比如数据处理，网络请求等）</p></blockquote><blockquote><p>【拓展】关于框架的底层架构原理<br>学习过程中你可能会接触到 MVP、MVC 和 MVVM，Vue 采用了 MVVM 架构，Angular 采用了 MVC 架构，而 React 作为 Javascript 库采用了虚拟 DOM 的方式实现了数据驱动视图的效果。<br><a href="https://juejin.cn/post/6844903825225023502?searchId=2024022816050469F71170640EAD6BE7F3">前端面试题：这是我理解的 MVVM，请注意查收</a> &gt; <a href="https://juejin.cn/post/6844903605414133773?searchId=2024022816050469F71170640EAD6BE7F3">MVVM 的实现</a></p></blockquote><h3 id="核心理念与方法"><a href="#核心理念与方法" class="headerlink" title="核心理念与方法"></a>核心理念与方法</h3><p>正如上文所说，虽然框架之间的实现方式和原理存在差异，但是他们有很多理念和方法是相同的，比如：</p><ul><li>组件化</li><li>组件通信</li><li>组件生命周期</li><li>路由管理</li><li>表单处理</li><li>状态管理</li><li>网络请求</li><li>异步数据处理</li><li>持久化存储</li><li>国际化</li><li>主题定制</li></ul><p>除了学习如何使用框架，还需要学习框架的底层原理，达到”知其所以然“的境界。</p><h2 id="5-2-UI-框架"><a href="#5-2-UI-框架" class="headerlink" title="5.2 UI 框架"></a>5.2 UI 框架</h2><p>UI 框架主要面向组件和交互功能，会封装常用的一些组件以供开发者使用，比如按钮、弹窗、表单、表格等，使用 UI 框架可以极大程度的减少 CSS 代码的编辑量，提高开发效率。常见的一些 UI 框架&#x2F;UI 库：</p><table><thead><tr><th>UI 框架&#x2F;UI 库</th><th>支持框架</th><th>支持终端</th></tr></thead><tbody><tr><td>Element-UI，Element-Plus</td><td>Vue</td><td>Web、移动端</td></tr><tr><td>TDesign，AntDesign，Material-UI</td><td>React</td><td>Web、移动端</td></tr><tr><td>NG-ZORRO</td><td>Angular</td><td>Web、移动端</td></tr><tr><td>Ionic</td><td>Angular、React、Vue</td><td>移动端</td></tr><tr><td>Tailwind CSS</td><td>原生 CSS 框架</td><td>不限制</td></tr></tbody></table><h1 id="6-开发理念"><a href="#6-开发理念" class="headerlink" title="6 开发理念"></a>6 开发理念</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><ul><li>组件化是指将页面或应用拆分为独立的可重用组件，每个组件包含自身的结构、样式和行为，并且可以独立使用或组合成更复杂的界面。</li><li>组件化的目的是提高开发效率、减少重复开发、保持代码一致性，同时促进团队协作和复用。</li><li>组件化通常是在界面层面进行划分，可以采用前端框架（如 Vue、React、Angular）提供的组件化机制来实现</li></ul><p>让我们回顾一下上文提到的问题：</p><blockquote><p>在一个 html 文件实现一个页面的结构中，如果想在每个页面实现相同的页面结构（比如导航栏），就需要在每个页面中都写一遍，这显然不合理，有没有更好的方法？</p></blockquote><p>基于框架实现组件化开发能够完美的解决这个问题。试想假如原来有 10 个页面，每个页面都展示导航栏，如果你想在导航栏中新增一个菜单，就要修改 10 遍导航栏代码！但是按照组件化开发的思路，写一套导航栏组件即可，这样后续有任何变更，也只需要修改一次导航栏组件即可，大大降低了后续维护的成本和难度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习HTML、CSS、JavaScript以及计算机网络的基础知识，结合框架，理论上你已经能够完成一个简单的前端页面了，接下来我们将会介绍如何构建一个完整的前端项目。</p><!-- 但是，如果你打开过框架的官方网站，就一定能看到类似的话：“必须先安装 node.js 和 npm（Node Package Manager）”。相信作为初学者的你和当时的我一样困惑，但没关系，你会在[前端知识体系概览（二）—— 技能进阶]()学到它的基础信息，并在[前端知识体系概览（三）—— 模块化和工程化]()中更深入的了解他们。 -->]]></content>
    
    
    <categories>
      
      <category>知识总览</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git大法好...难</title>
    <link href="/2024/02/23/git%E5%A4%A7%E6%B3%95%E5%A5%BD..%E9%9A%BE/"/>
    <url>/2024/02/23/git%E5%A4%A7%E6%B3%95%E5%A5%BD..%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<p>说起来使用 Git 已经 7 月有余，虽然不至于再出现合并冲突把别人代码覆盖的的低级错误，但是还是会遇到各种问题，反复学习了若干次 Git，只是熟悉了一些基本的操作，遇到问题时还是解释清楚。但是没关系，查漏补缺，多学几遍总会明白的。</p><span id="more"></span><h1 id="1-发展历史与原理"><a href="#1-发展历史与原理" class="headerlink" title="1. 发展历史与原理"></a>1. 发展历史与原理</h1><h2 id="1-1-版本控制系统发展历史与分类"><a href="#1-1-版本控制系统发展历史与分类" class="headerlink" title="1.1 版本控制系统发展历史与分类"></a>1.1 版本控制系统发展历史与分类</h2><ol><li><strong>本地版本控制系统</strong>：在本地电脑上采用简单数据库控制版本变更。</li><li><strong>集中化的版本控制系统</strong>：使用单一的集中管理的服务器，存储所有的文件修订版本。但是当中央服务器出现单点故障时，将对所有开发工作造成影响。</li><li><strong>分布式版本控制系统</strong>：比如 Git，Mercurial 以及 Darcs 等，每一个电脑上都存储了整个代码仓库的完备记录，任何一处协同工作的服务器出现故障时，都可以从其他镜像的本地仓库进行复原。</li></ol><h2 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h2><p>Git 与其他分支控制系统最大的差异是对待数据的形式，它直接记录了文件快照，而非记录文件的变更量。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 <strong>基于差异（delta-based</strong> 的版本控制）。</p><p>在 Git 中，更像是把数据看作小型文件系统的一系列快照。当文件发生变更时，就会对当前的所有文件创建一个快照，并且记录指向这个快照的索引。为了提高效率，当文件没有发生变更时，git 就不会再保存文件，而是记录一个链接指向之前的存储的文件。</p><ul><li>这个<strong>链接</strong>是什么？</li></ul><p>在 git 保存所有文件变更之前，都会计算<span style="color:green">校验和</span>。在 git 中计算校验和的机制叫做<span style="color:green">SHA-1 散列（hash，哈希）</span>。这是一个由 40 个十六进制自负(0-9 和 a-f)组成的字符串，基于 Git 中文件的内容和目录结构计算出来。SHA-1 哈希看起来是这样：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code><br>在 Git 中，都是用这个校验和（哈希值，即上文提到的链接）作为文件的引用，而不是文件名。</p><h2 id="1-3-Git-仓库"><a href="#1-3-Git-仓库" class="headerlink" title="1.3 Git 仓库"></a>1.3 Git 仓库</h2><p>Git 分成几个重要的部分，工作区，暂存区，本地仓库，远端仓库。<br><img src="/img/blog/git-1.1.png" alt="git基本操作" title="git基本操作"></p><ol><li><span style="color:orange">本地到远端的操作</span></li><li><span style="color:purple">远端到本地的操作</span></li></ol><h1 id="2-Git-常用操作"><a href="#2-Git-常用操作" class="headerlink" title="2. Git 常用操作"></a>2. Git 常用操作</h1><p><span style="color:orange">最最最最最最常用的操作</span></p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>add</td><td>将文件添加到暂存区</td><td></td></tr><tr><td>commit</td><td>将暂存区的文件提交到本地仓库</td><td></td></tr><tr><td>push</td><td>将本地仓库的文件推送到远端仓库</td><td></td></tr><tr><td>pull</td><td>拉取远端仓库的文件内容并更新本地分支</td><td></td></tr><tr><td>fetch</td><td>拉取远端仓库的文件</td><td></td></tr><tr><td>merge</td><td>合并远端分支到本地分支</td><td></td></tr><tr><td>stash</td><td>将文件添加到暂存区</td><td></td></tr><tr><td>revert</td><td></td><td></td></tr></tbody></table><p>安装和配置</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>init</td><td>初始化仓库</td><td></td></tr><tr><td>clone</td><td>克隆仓库</td><td></td></tr></tbody></table><p>获取和创建项目</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead></table><p>基础快照</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>add</td><td></td><td></td></tr><tr><td>status</td><td></td><td></td></tr><tr><td>diff</td><td></td><td></td></tr><tr><td>commit</td><td></td><td></td></tr><tr><td>notes</td><td></td><td></td></tr><tr><td>restore</td><td></td><td></td></tr><tr><td>reset</td><td></td><td></td></tr><tr><td>rm</td><td></td><td></td></tr><tr><td>mv</td><td></td><td></td></tr></tbody></table><p>分支和合并</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>branch</td><td></td><td></td></tr><tr><td>checkout</td><td></td><td></td></tr><tr><td>switch</td><td></td><td></td></tr><tr><td>merge</td><td></td><td></td></tr><tr><td>mergetool</td><td></td><td></td></tr><tr><td>log</td><td></td><td></td></tr><tr><td>stash</td><td></td><td></td></tr><tr><td>tag</td><td></td><td></td></tr><tr><td>worktree</td><td></td><td></td></tr></tbody></table><p>分享和更新项目</p><table><thead><tr><th>操作</th><th>作用</th><th>使用范例</th></tr></thead><tbody><tr><td>fetch</td><td></td><td></td></tr><tr><td>pull</td><td></td><td></td></tr><tr><td>push</td><td></td><td></td></tr><tr><td>remot</td><td></td><td></td></tr><tr><td>submodule</td><td></td><td></td></tr></tbody></table><p>检查和比较</p><p>修补</p><p>调试</p><p>管理</p><h1 id="开发问题"><a href="#开发问题" class="headerlink" title="开发问题"></a>开发问题</h1><h2 id="1-代码相同，为什么还是检测出了变更"><a href="#1-代码相同，为什么还是检测出了变更" class="headerlink" title="1. 代码相同，为什么还是检测出了变更"></a>1. 代码相同，为什么还是检测出了变更</h2><p><strong>有远端分支 a 和本地分支 b，通过 git push origin b 将本地分支 b 推送至远端，然后发起合并请求，将远端分支 b 合并进 a，但是在对比变更的时候发现，有些在 a 上的代码和 b 上相同，但是还是提示有变更。</strong></p><p>解析：</p><p>当你将远程分支 B 合并到远程分支 A 时，即使在两个分支上存在相同的代码，也可能会出现提示有变更的情况。这通常是因为 git 在判断是否有变更时，是通过比较提交历史和具体文件内容来确定的。<br>即使两个分支上的某些文件内容相同，在提交历史中它们可能是不同的。这可能是因为这些相同的文件在两个分支上的修改历史并不一样，导致 git 认为它们是不同的版本，从而在合并请求中显示有变更。<br>另外，即使文件内容没有改变，如果文件的元数据（如文件权限或时间戳）发生了变化，git 也会认为这是一个变更。<br>如果你确定两个分支上的代码实际上是相同的，且不希望在合并请求中显示这些“变更”，你可以考虑使用 git rebase 或者 git merge –squash 来合并分支，以减少重复的提交历史记录和变更。这样可以避免在合并请求中出现不必要的变更提示。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://git-scm.com/book/zh/v2">Git官方文档</a></li><li><a href="https://juejin.cn/post/6844903702374023182">对比 Git 与 SVN，这篇讲的很易懂</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript索引签名</title>
    <link href="/2024/02/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/02/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<p>已知字符串”str”，尝试通过 obj[‘str’]获取对象 obj 的 str 属性值，但在 typescript 中语法报错。</p><span id="more"></span><h1 id="1-需求描述及实现方式"><a href="#1-需求描述及实现方式" class="headerlink" title="1. 需求描述及实现方式"></a>1. 需求描述及实现方式</h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h2><p>在管理端配置自助端的首页功能菜单，在自助端显示配置开关开启的菜单。<br>比如，在管理端设置开启 a&#x2F;b&#x2F;c 功能菜单的开关，则在自助端显示 a&#x2F;b&#x2F;c 功能菜单按键，不显示其他内容。</p><h2 id="2-实际实现方式"><a href="#2-实际实现方式" class="headerlink" title="2.实际实现方式"></a>2.实际实现方式</h2><ol><li>涉及两个接口：setConfig 和 getConfig，分别用于保存配置和获取配置，接口的 data 为属性为布尔值的对象，表示是否显示对应的菜单项。</li><li>管理端：加载页面时，使用 getConfig 的内容更新页面 form 的值，进行数据回显。修改数据进行保存时，使用 setConfig 的 post 方法，修改管理端配置。</li><li>自助端：加载首页时，使用 getConfig 获取配置，并使用 filter 方法过滤菜单数组，仅保留对应 showXXX 属性为 true 的值。</li></ol><p>定义了 SelfConfigFields，规定了接口数据的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelfConfigFields</span> &#123;<br>  <span class="hljs-attr">showApply</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showApplyRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showRegisterRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showOffline</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbindingDevice</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbinding</span>: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了 functionList 用于渲染功能菜单，其中 showKey 的属性值为字符串，指向配置查询接口中对应的属性名称。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">functionList = <span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    logUrl<span class="hljs-punctuation">:</span> &#x27;assets/imgs/pc/apply-filing-green.png&#x27;<span class="hljs-punctuation">,</span><br>    name<span class="hljs-punctuation">:</span> &#x27;apply-filing&#x27;<span class="hljs-punctuation">,</span><br>    tip<span class="hljs-punctuation">:</span> &#x27;&#x27;<span class="hljs-punctuation">,</span><br>    index<span class="hljs-punctuation">:</span> &#x27;apply-filing&#x27;<span class="hljs-punctuation">,</span><br>    showKey<span class="hljs-punctuation">:</span> &#x27;showApply&#x27;<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span>;<br></code></pre></td></tr></table></figure><p>在尝试通过 getSelfConfig 方法过滤 show 为 false 的值时</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 获取自助中心配置</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-title function_">getSelfConfig</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">aggregationProtalService</span>.<span class="hljs-title function_">getSelfConfig</span>().<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">functionList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">functionList</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>       <span class="hljs-keyword">return</span> res[item.<span class="hljs-property">showKey</span>]<br>     &#125;)<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><p>在<code>return res[item.showKey]</code>处会出现报错:<br><span style="color:orangered;font-size:14px">元素隐式具有 “any” 类型，因为类型为 “string” 的表达式不能用于索引类型 “SelfConfigFields”。在类型 “SelfConfigFields” 上找不到具有类型为 “string” 的参数的索引签名。</span></p><h1 id="2-知识点解析"><a href="#2-知识点解析" class="headerlink" title="2.知识点解析"></a>2.知识点解析</h1><h2 id="1-读取对象属性"><a href="#1-读取对象属性" class="headerlink" title="1. 读取对象属性"></a>1. 读取对象属性</h2><ol><li>通过点属性读取<br>点属性访问器是在 JavaScript 中访问对象属性的最常见和最直接的方式。它使用点 (.) 表示法来访问对象的特定属性。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>通过方括号读取<br>直接通过字符串读取</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[<span class="hljs-string">&quot;name&quot;</span>]);<br></code></pre></td></tr></table></figure><p>通过变量读取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;name&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[name]);<br></code></pre></td></tr></table></figure><h2 id="2-TypeScript-索引签名"><a href="#2-TypeScript-索引签名" class="headerlink" title="2. TypeScript 索引签名"></a>2. TypeScript 索引签名</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>在 TypeScript 中，索引签名是一种定义对象类型的方式，它允许我们使用<strong>字符串或数字</strong>作为索引来访问对象的属性。</p><p>索引签名最主要的作用就是允许我们动态地添加或访问对象的属性，当我们事先不知道类型属性的所有名称及其值的形状时, 索引签名指定当一个对象被一个字符串索引时，它返回一个指定类型的值。</p><h3 id="2-写法"><a href="#2-写法" class="headerlink" title="2. 写法"></a>2. 写法</h3><ol><li><p>字符串索引签名：<code>[index:string]:type</code></p></li><li><p>数字索引签名:<code>[index:number]:type</code></p></li></ol><p>但是需要保证索引签名的类型和实际属性的类型相匹配：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">//会报错，因为索引签名指定，当通过字符串索引时，对应的类型应该是string，但是name的类型为number</span><br>&#125;<br><span class="hljs-comment">//正确的写法：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">//以下三种写法都可以</span><br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;<br>  [<span class="hljs-attr">index</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-索引签名的使用"><a href="#3-索引签名的使用" class="headerlink" title="3. 索引签名的使用"></a>3. 索引签名的使用</h3><p>对照上文的需求，应该在 SelfConfigFields 中添加<code>[key: string]: boolean;</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SelfConfigFields</span> &#123;<br>  <span class="hljs-attr">showApply</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showApplyRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showRegisterRecords</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showOffline</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbindingDevice</span>: <span class="hljs-built_in">boolean</span>;<br>  <span class="hljs-attr">showUnbinding</span>: <span class="hljs-built_in">boolean</span>;<br>  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">boolean</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，通过字符串访问对象的属性时，就不会再报错了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> showName = item.<span class="hljs-property">showKey</span>; <span class="hljs-comment">//&#x27;showApply&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res[showName]); <span class="hljs-comment">//res[&#x27;showApply&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/7223679441901240376">js如何获取对象中的所有属性</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>到底什么是像素值清晰度？</title>
    <link href="/2024/02/10/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%8F%E7%B4%A0%E5%80%BC%E6%B8%85%E6%99%B0%E5%BA%A6%EF%BC%9F/"/>
    <url>/2024/02/10/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%8F%E7%B4%A0%E5%80%BC%E6%B8%85%E6%99%B0%E5%BA%A6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>最近想要生成一个分享海报，需要将背景图和二维码拼接后生成一个新的图片，并通过h5&#x2F;app下载。最初用canvas实现了图片拼接，但是在导出的时候遇到了问题，同样的海报尺寸，为什么h5导出的图片2M,app导出图片的尺寸却有12M？</p><p>为了导出清晰度又高占内存又小的图片，赶紧恶补关于图像的知识，试图弄清楚图片的尺寸、像素值、清晰度和图片容量大小的关系。</p><span id="more"></span><h1 id="遇到的疑问"><a href="#遇到的疑问" class="headerlink" title="遇到的疑问"></a>遇到的疑问</h1><ol><li>为什么在h5和app上绘制的canvas尺寸都是一样的，导出图片的尺寸也一样，大小却是一个2M一个12M？</li><li>为什么1M的图片和12M的图片一样清晰，到底是什么决定了图片的清晰度？</li><li>为什么微信扫码可以识别psd导出的1M海报，却不能识别我通过canvas导出的1M海报，尽管他俩的清晰度看起来完全一样，这两张图片的差别是什么？</li></ol><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><h2 id="1-像素"><a href="#1-像素" class="headerlink" title="1. 像素"></a>1. 像素</h2><p>像素分为逻辑像素（数字像素）和物理像素。</p><ol><li>逻辑像素（Digital Pixel）：逻辑像素是在数字图像中使用的概念，我们经常提到的“像素”就指的是逻辑像素。逻辑像素是图像的基本单位，表示图像最小可见元素。可以将像素理解成一个小方块，一张图片由若干小方块（像素点）组成，每个像素点都有自己的颜色和位置信息。</li><li>物理像素（Physical Pixel）：物理像素是实际显示设备的像素单元。我们可以这么理解，物理像素是硬件开发相关的单位，是基于一个一个的硬件小方块，其大小由硬件厂家设定。</li></ol><h2 id="2-分辨率"><a href="#2-分辨率" class="headerlink" title="2. 分辨率"></a>2. 分辨率</h2><p>和像素一样，分辨率也分为逻辑分辨率和物理分辨率。</p><ol><li>逻辑分辨率通常用于描述图像的像素数量，即水平方向和垂直方向上的像素数量。</li><li>物理分辨率：我们常说的屏幕分辨率指的是物理像素的数量，比如说，分辨率为1920*1080的屏幕，指的是屏幕纵向上有1920像素(px)，横向上有1080像素(px)。</li></ol><h2 id="3-清晰度"><a href="#3-清晰度" class="headerlink" title="3. 清晰度"></a>3. 清晰度</h2><p>为什么相同分辨率的图片，清晰度却不同？</p><p>这是因为像素比只是决定清晰度的一个方面，还有其他原因决定了图片的清晰度：</p><ol><li>压缩方式：比如JPEG图片通常采用有损压缩，可能导致图像细节的丢失，而PNG图片使用无损压缩，能够更好地保留图像细节。</li><li>拍摄设备的质量</li><li>后期处理</li><li>拍摄环境</li></ol><h2 id="4-占用容量大小"><a href="#4-占用容量大小" class="headerlink" title="4. 占用容量大小"></a>4. 占用容量大小</h2><p>文件大小描述了图片文件所占据的存储空间大小，通常来说，图片的占用容量大小描述了以下几个方面：</p><ol><li>文件大小：描述了图片文件在计算机或其他设备中所占据的实际大小。较大的文件大小通常表示图片包含更多的像素和颜色信息，或者使用了较低效率的压缩方法。</li><li>清晰度和细节：通常情况下，占用容量较大的图片具有更多的细节和更高的清晰度，占用容量较小的图片可能会出现失真和模糊，因为他们经过了更多的压缩处理。</li><li>压缩质量：较小的文件大小可能意味着采用了更高效的压缩方法，但有可能导致图片质量下降。</li></ol><h1 id="2-计量单位"><a href="#2-计量单位" class="headerlink" title="2. 计量单位"></a>2. 计量单位</h1><h2 id="1-像素比-DPR"><a href="#1-像素比-DPR" class="headerlink" title="1. 像素比(DPR)"></a>1. 像素比(DPR)</h2><p><strong>像素比 &#x3D; 物理像素&#x2F;逻辑像素</strong></p><p>注：这里的物理像素和逻辑像素，指的是像素的个数，即绘制相同尺寸的图像所需要的物理像素&#x2F;逻辑像素的个数。<br>像素比描述了物理像素和逻辑像素的比值，即<strong>用几个物理像素可以绘制一个逻辑像素</strong>。</p><p>在相同设备上，缩放网页比例，实际就是变更了像素比，当像素比越大时，屏幕能够显示的图片范围就越大。比如有一张分辨率为1234*1234的图片，在1920*1080分辨率的电脑上，就只能显示一小部分。而当我们把图片的像素比（DPR）放大时，图片就会缩小，我们也能看到更多的区域。</p><p>注：在uniapp中可以通过如下方式获取设备的像素比，M10 pro的输出结果为2.7</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> dpr = uni.<span class="hljs-title function_">getSystemInfoSync</span>().<span class="hljs-property">pixelRatio</span>; <span class="hljs-comment">// 获取设备像素比</span><br></code></pre></td></tr></table></figure><h2 id="2-设备分辨率（DPI）"><a href="#2-设备分辨率（DPI）" class="headerlink" title="2. 设备分辨率（DPI）"></a>2. 设备分辨率（DPI）</h2><p>DPI（Dots Per Inch），设备分辨率指的是各类输出设备每英寸上可产生的点数，dpi越大，屏幕显示越细腻。</p><h2 id="3-图像大小的单位"><a href="#3-图像大小的单位" class="headerlink" title="3. 图像大小的单位"></a>3. 图像大小的单位</h2><ul><li><strong>像素（Pixel）</strong>：像素是图像的最小单元，通常用来表示数字图像的分辨率。例如，一个图像的大小可以表示为宽度 x 高度（像素）。例如，2034 x 4393px。</li><li><strong>字节（Byte）</strong>：字节是计算机中存储数据的基本单位，用来表示图像文件的大小。较小的图像通常以字节为单位，例如几百字节或几千字节（KB）。</li><li><strong>千字节（Kilobyte）</strong>：千字节是存储容量的单位，等于1024字节（2^10字节）。较大的图像文件通常以千字节（KB）为单位来表示其大小。</li><li><strong>兆字节（Megabyte）</strong>：兆字节是存储容量的单位，等于1024千字节（2^20字节）。较大的图像文件或高分辨率图像通常以兆字节（MB）为单位来表示其大小。</li><li><strong>吉字节（Gigabyte）</strong>：吉字节是存储容量的单位，等于1024兆字节（2^30字节）。非常大的图像文件或专业图像素材可能以吉字节（GB）为单位来表示其大小。</li></ul><h1 id="问题回顾与解答"><a href="#问题回顾与解答" class="headerlink" title="问题回顾与解答"></a>问题回顾与解答</h1><ol><li><p>为什么在h5和app上绘制的canvas尺寸都是一样的，导出图片的尺寸也一样，大小却是一个2M一个12M？<br>因为在app上导出canvas时，没有做任何图片的压缩处理，导致占用容量过大。</p></li><li><p>为什么1M的图片和12M的图片一样清晰，到底是什么决定了图片的清晰度？<br>和1相同，1M的图片采用了压缩算法，能够很好的缩小图片占用的空间大小。在app导出图片时增加压缩方法，实现了在保证图片质量的情况下缩小图片尺寸。</p></li><li><p>为什么微信扫码可以识别psd导出的1M海报，却不能识别我通过canvas导出的1M海报，尽管他俩的清晰度看起来完全一样，这两张图片的差别是什么？<br>微信扫码识别图片时，可能会收到图片格式、压缩算法、色彩深度等因素的影响。最终的解决办法是增大了二维码区域，这样微信就可以正常识别了。</p></li></ol><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://juejin.cn/post/7190723647030427708?searchId=202402102238257CF36A5131E20B589B24">关于物理像素、逻辑像素（css像素）、分辨率、像素比的超详细讲解</a></li><li><a href="https://juejin.cn/post/6918323869824909319?searchId=2024021023301590C1F01125A47F5F2D7C">作为前端，你应该了解的分辨率&#x2F;逻辑像素&#x2F;物理像素&#x2F;retina屏知识🧐</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>页面</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 安装和配置</title>
    <link href="/2024/02/07/Hexo%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/02/07/Hexo%20%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>一直以来，我都有用博客记录学习的想法，但是未能实现。机缘巧合下，看到了一位大佬用Hexo做的个人博客，终于决定尝试一下。所以就从第一篇Hexo的安装和配置开始吧～</p><span id="more"></span><h1 id="1-运行环境"><a href="#1-运行环境" class="headerlink" title="1.运行环境"></a>1.运行环境</h1><ul><li>打开zsh，下载python: <code>brew install python3</code></li><li>下载node: <code>brew install node</code></li><li>检查python和node是否安装成功: <code>python -v</code> <code>node -v</code></li><li>npm安装hexo: <code>npm install hexo-cli -g</code><br>经过以上几个步骤，hexo所需的运行环境和基础工具包已经具备</li></ul><h1 id="2-Hexo初始配置"><a href="#2-Hexo初始配置" class="headerlink" title="2.Hexo初始配置"></a>2.Hexo初始配置</h1><ul><li>在本地需要放置博客的位置，创建目录:<code>mkdir blog</code></li><li>进入目录: <code>cd blog</code></li><li>将blog初始化为hexo博客文件夹:<code>hexo init</code></li><li>添加通过git上传本地文章的工具包：<code>npm install hexo-deployer-git --save</code></li><li>删除&#x2F;blog&#x2F;source&#x2F;_post&#x2F;目录下的初始化文章:<code>rm source/_post/Hello-world.md</code></li><li>创建自己的第一篇博客，如:<code>hexo n &quot;Hexo 安装和配置&quot;</code></li><li>生成博客的静态文件:<code>hexo generate</code>(可简写为<code>hexo g</code>)</li><li>运行到本地:<code>hexo server</code>(可简写为<code>hexo s</code>)<br>然后打开 <a href="http://localhost:4000/">http://localhost:4000/</a>就可以看到运行在本地的博客</li></ul><h1 id="3-部署配置"><a href="#3-部署配置" class="headerlink" title="3.部署配置"></a>3.部署配置</h1><h2 id="3-1-GitHub-Pages"><a href="#3-1-GitHub-Pages" class="headerlink" title="3.1 GitHub Pages"></a>3.1 GitHub Pages</h2><p>GitHub Pages 是 GitHub 提供的一项静态网站托管服务，可以免费将代码仓库转换成一个完全可访问的静态网站。这对前端工程师来说真是太友好了～</p><ul><li>本地安装git和ssh: <code>brew install git ssh</code></li><li>git配置用户名和邮箱地址: <code>git config --global user.name &quot;your_name&quot; --global user.email &quot;your_email&quot;</code></li><li>ssh生成本地公钥pub_key: <code>ssh-keygen -t rsa -C &quot;your_email&quot;</code></li><li>在本地~&#x2F;.ssh目录下可以看到生成的公钥: <code>cat ~/.ssh/id_rsa.pub</code></li><li>复制公钥，打开自己的github，右上角头像 setting -&gt; 左侧导航栏 SSH and GPG keys -&gt; 中间网页content的右上角 New SSH key -&gt; 填写 Title 并粘贴公钥到 key 中 -&gt; 点击Add SSH key完成配置</li><li>在~&#x2F;.ssh目录下创建config文件: <code>touch ~/.ssh/config</code><br>如果已有config文件，则使用 <code>vim ~/.ssh/config</code></li><li>将以下配置写入config中:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Host</span> <span class="hljs-string">GitHub.com</span><br>    <span class="hljs-string">Hostname</span> <span class="hljs-string">ssh.github.com</span><br>    <span class="hljs-string">Port</span> <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><ul><li>本地机器与github建立连接：<code>ssh -T git@github.com</code> 出现下列信息代表连接github成功：</li></ul><p><code>Hi &#123;YourName&#125;! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></p><ul><li>在Github创建自己的仓库: <code>&#123;username&#125;/&#123;username&#125;.github.io</code> 注意仓库的名称一定是github的username加上.github.io</li><li>在仓库Setting的左侧导航栏找到Pages，自行设置分支（github默认分支名main，可以根据实际情况更改成master）</li><li>在本地blog目录下上传自己的博客到github中: <code>hexo d</code>,等待上传即可<ul><li>注：我在这里遇到了问题，理论上来说建立ssh链接后就无需输入帐密。但是此处需要输入username和password才允许上传，并且这里的password是github的token,可以在<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>中生成</li></ul></li></ul><p>完成上述步骤后，刷新github页面，可以在setting中的GitHub Pages中可看到visit site 按钮，点击跳转可以看到部署在github上的博客<br>借助Github Pages，现在可以通过<code>https://&#123;username&#125;.github.io</code>访问仓库了，可以选择购买域名实现域名自定义</p><h2 id="3-2-Netify部署"><a href="#3-2-Netify部署" class="headerlink" title="3.2 Netify部署"></a>3.2 Netify部署</h2><p>也可以选择现有的网站托管平台，一键部署到网站上并自定义域名。</p><ul><li>以Netify为例，<a href="https://app.netlify.com/start">新建一个网站页面</a>，选择需要关联的 Github&#x2F;BitBucket&#x2F;Gitlab 库，然后遵循网站提示进行配置</li></ul><p>此外，您还可以在项目的README中增加一个 部署至Netlify按钮，这样其他用户在fork或clone了您的项目之后可以方便快捷地一键部署</p><h1 id="5-主题配置"><a href="#5-主题配置" class="headerlink" title="5.主题配置"></a>5.主题配置</h1><p>该博客使用的主题为Fuild</p><ul><li><p>主题地址:<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p></li><li><p>用户手册:<a href="https://hexo.fluid-dev.com/docs/">https://hexo.fluid-dev.com/docs/</a></p></li><li><p>安装fluid主题 <code>npm install --save hexo-theme-fluid</code></p></li><li><p>在blog目录下创建<code>_config.fluid.yml</code>,<code>touch _config.fluid.yml</code>,将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a>内容复制过去。</p></li></ul><h1 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h1><ul><li>每次<code>hexo g</code>之前都<code>hexo clean</code>一下</li><li>使用<code>hexo deploy</code>部署到github上</li><li>hexo文档 <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li><li>更多部署方式详见 <a href="https://hexo.io/zh-cn/docs/one-command-deployment">hexo部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>流程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
